<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot日志.md]]></title>
    <url>%2F2020%2F08%2F10%2FSpringBoot%2FSpringBoot%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[SpringBoot使用的日志框架 SpringBoot使用的是slf4j + logback日志实现 导入其他的包将其他组件的日志实现转换成slf4j 使用日志1234567Logger logger = LoggerFactory.getLogger(getClass());// 日志的级别由低到高logger.trace("trace level");logger.debug("debug level");logger.info("info level");logger.warn("warn level");logger.error("error level"); SpringBoot默认的日志级别是INFO，只会输出级别大于info的日志信息。可以在配置文件中设置日志级别。 12345// 调整全局的日志级别logging.level.root=trace// 调整某个包的日志级别logging.level.com.sise.jpa=trace 指定日志配置文件位置在配置文件中可以指定日志输出的位置： logging.file.name logging.file.path 描述 [none] [none] 只在控制台输出 指定文件名 [none] 输出日志到指定文件名中，不指定路径在当前项目下生成指定文件名的文件 [none] 指定目录 输出到指定目录的spring.log文件中 指定文件名 指定文件夹 输出日志到指定文件名中 1234567891011// 日志输出存放在当前项目目录下，文件名称为springboot.loglogging.file.name=springboot.log// 日志输出存放到指定目录下的指定文件名logging.file.name=C:\\Users\\zjm16\\Desktop\\springboot.log// 日志输出存放在当前项目下的指定目录下logging.file.name=spring/log/springboot.log// 日志输出存放在指定的文件夹，文件名称为默认的spring.loglogging.file.path=spring/log 总结: logging.file.name 可以指定路径和log文件的名字 logging.file.path 只可以只当log的路径, 不能指定log的名字, 使用缺省值spring.log 二者只可以存在一个 ###]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lambda.md]]></title>
    <url>%2F2020%2F08%2F10%2FJava%2FLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Java 8 新特性 Lambda表达式，代码更少 Stream API Optional，最大化减少空指针异常 便于并行 Nashom引擎，允许在JVM上运行JS应用 Lambda表达式一段可以传递行为的代码…. 举个栗子： 1.不使用Lambda表达式： 匿名类…注意需要加上；结尾 1234567891011public void test3()&#123; Comparator&lt;Integer&gt; c = new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return Integer.compare(o1,o2); &#125; &#125;; int result = c.compare(12, 22); System.out.println(result);&#125; 2.使用Lambda表达式： 12345public void test4()&#123; Comparator&lt;Integer&gt; c = (o1,o2) -&gt; Integer.compare(o1,o2); int result = c.compare(12, 22); System.out.println(result);&#125; 3.使用函数引用： 12345public void test5()&#123; Comparator&lt;Integer&gt; c = Integer::compare; int result = c.compare(12, 22); System.out.println(result);&#125; Lambda表达式的使用 本质：函数式接口的实例对象。 * 函数式接口：只有一个抽象方法的接口 函数式接口才能使用Lambda表达式 格式 -&gt; lambda操作符 (o1,o2)：形参列表，其实就是接口中的抽象方法的形参列表) 右边：抽象方法的方法体 使用 无参，无返回值 123() -&gt; &#123; System.out.println("测试Lambda");&#125; &gt;有且只有一个参数，无返回值 123Consumer&lt;String&gt; -&gt; (String s) -&gt; &#123; System.out.println(s);&#125; &gt;数据类型可以省略，由编译器推断出来 123Consumer&lt;String&gt; -&gt; (s) -&gt; &#123; System.out.println(s);&#125; 若只有一个参数，参数的小括号可以省略 123Consumer&lt;String&gt; -&gt; s -&gt; &#123; System.out.println(s);&#125; 两个以上的参数，多条执行语句，有返回值 12345Comparator&lt;Integer&gt; c = (o1,o2) -&gt; &#123; System.out.println(o1); System.out.println(o2); return o1.compareTo(o2);&#125; 当Lambda体只有一条执行语句，return 与 {} 都可以省略 ​ 1(o1,o2) -&gt; o1.compareTo(o2); 总结： Lambda的参数类型可以省略，由编译器推断，但是不一定准确(左边） 形参有且仅有一个时，()可以省略(左边） 只有一条执行语句，return 和 {} 可以省略(右边） 函数式接口 可以在函数式接口上加上@FunctionalInterface注解，这样做可以检查它是不是函数接口 Lambda表达式就是一个函数式接口的实例 以前的匿名实现类现在都可以使用Lambda表达式来写 Java 内置的四大函数式接口 Consumer：消费性接口，对参数类型为T的对象进行操作，不返回结果。包含方法void accept(T t) Supplier：供给型接口，返回类型为T的对象，不接收参数。包含方法T get() Function&lt;T,K&gt;：函数型接口，可以接收参数，可以有返回值。对参数类型为T的对象进行操作，返回结果为K类型的对象。包含方法K apply(T t) Predicate：断定型接口，判断T类型的参数是否满足某约束，并返回boolean值，包含方法boolean test(T t) 函数式接口举例子定义一个过滤字符串的方法，该方法传入字符串List和Predicate接口，利用Predicate接口的test()方法判断是否满足某种规则，满足则返回。 123456789public List&lt;String&gt; filterStrings(List&lt;String&gt; strs, Predicate&lt;String&gt; pre)&#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); strs.forEach(s -&gt; &#123; if(pre.test(s))&#123; list.add(s); &#125; &#125;); return list; &#125; 具体的判断规则，在调用的时候传递进去： 12345public void test8()&#123; List&lt;String&gt; strings = Arrays.asList("北京", "天津", "南京"); List&lt;String&gt; list = filterStrings(strings, s -&gt; s.contains("京")); System.out.println(list); &#125; 方法引用 当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用 要求：实现接口的抽象方法的参数列表和返回值，必须和方法引用的参数列表的和返回值类型保持一致 格式：使用操作符：：将类(对象) 与 方法名分隔开来 主要使用形式： 对象：：实例方法 类：：静态方法 类：：实例方法]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot热部署.md]]></title>
    <url>%2F2020%2F08%2F10%2FSpringBoot%2FspringBoot%E7%83%AD%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[导入devtools jar 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 这里要注意的是，一定要确保devtools导入成功。有时候在pom.xml文件中是没有报错的，但是在右侧的maven工具栏看是有红色下划线的，最好检查一下jar包是不是正确的导入了。 还有一点是一定要设置optional才生效 devtools监听的实际上是target目录下的class文件，只有class文件发生了改变，devtools才会重启服务器。那么，我们可以通过2种方法来更新target目录下的class文件。 手动build project 通过idea设置自动更新 idea设置自动热部署 这样，当改动java文件时，idea会自动更新target目录下的class文件，从而触发devtools重启服务器，完成了热部署。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot热部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot配置.md]]></title>
    <url>%2F2020%2F08%2F10%2FSpringBoot%2FSpringBoot%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[现有一个实体类Person,现在我们需要把实体类的属性从配置文件中导入： @ConfigurationProperties是从配置文件中导入属性的关键注解。prefix指定导入的是配置文件的person开头的属性。 @Getter、@Setter是必须的 @Component也是必须的。必须是IOC容器中的类，才能从配置文件中导入属性。在使用的时候，也必须是通过@Autowaired注入的，如果通过new创建的对象，不会注入配置文件中的属性。 123456789101112131415@Component@ConfigurationProperties(prefix = "person")@Getter@Setter@ToStringpublic class Person &#123; private String name; private Integer age; private Boolean isBoy; private Date birthday; private Date birthday; private Map&lt;String, Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog;&#125; yml配置文件的写法： 注意每个值前面的空格。 属性左边只要对齐就可以，对缩进的字符个数没有限制。 键值对和对象的写法是一样的。因为对象也是键值对 12345678person: name: lisi age: 20 is-boy: true birthday: 2020/02/01 maps: &#123;k1: v1,k2: 17&#125; lists: [aaa,bbb,ccc] dog: &#123;name: mydog,age: 6&#125; 关于map，list，还有另外一种写法： 注意Person类中是驼峰命名的方式，在yml中可以是-的写法。 123456789101112131415person: name: lisi age: 20 is-boy: true birthday: 2020/02/01 maps: k1: v1 k2: 17 lists: - aaa - bbb - ccc dog: name: mydog age: 6 properties文件的写法： 123456789person.name=zhangsanperson.age=18person.is-boy=trueperson.birthday=2020/03/03person.maps.k1=v1person.maps.k2=18person.lists=aaa,bbb,cccperson.dog.name=mydogperson.dog.age=7 运行结果： 虽然yml中是is-boy的写法，但是输出的结果还是Person类中的isBoy。同时注意到，日期格式与配置文件中的不同。 12345678910111213141516171819&#123; "name": "lisi", "age": 20, "isBoy": true, "birthday": "2020-01-31T16:00:00.000+0000", "maps": &#123; "k1": "v1", "k2": 17 &#125;, "lists": [ "aaa", "bbb", "ccc" ], "dog": &#123; "name": "mydog", "age": 6 &#125;&#125; 关于配置文件优先级问题当同时存在yml文件和properties文件时，properties文件的优先级大于yml文件。 关于中文乱码问题配置文件的默认编码是ASCII，而在idea中，设置了文件的编码是UTF8，就会导致乱码。 需要在Setting -&gt; File Encodings中设置在运行时将UTF8编码转换成ASCII编码： 使用@Value注入配置文件中的值 @Value注解不可以注入复杂类型(map,list,对象等)的数据。 @Value可以使用spel表达式进行计算。比如#{11 * 2} @Value不支持数据验证 @Value不支持松散语法，比如配置文件的is-boy，使用@Value注解不能写成isBoy。但是配置文件中的isBoy，使用@Value却可以写成is-boy。 黑人问号？？？ 1234567891011121314151617@Component@Getter@Setter@ToStringpublic class Person &#123; @Value("$&#123;person.name&#125;") private String name; @Value("#&#123;11 * 2&#125;") private Integer age; @Value("$&#123;person.is-boy&#125;") private Boolean isBoy; @Value("$&#123;person.birthday&#125;") private Date birthday; private Map&lt;String, Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog;&#125; 数据验证只有使用@ConfigurationProperties才能使用数据验证。@Value的数据校验是无效的。 数据验证需要@Validated注解。 12345678910111213141516@Component@Getter@Setter@ToString@Validated@ConfigurationProperties(prefix = "person")public class Person &#123; private String name; @Max(value = 3) private Integer age; private Boolean isBoy; private Date birthday; private Map&lt;String, Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog;&#125; 使用@Value注解时，使用数据验证。controller访问会出现奇怪的结果。 而通过单元测试可以发现通过@Value的注入方式，数据校验是无效的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#123; "name": "李四", "age": 22, "isBoy": true, "birthday": "2020-01-31T16:00:00.000+0000", "maps": null, "lists": null, "dog": null, "frozen": false, "proxiedInterfaces": [ ], "proxyTargetClass": true, "exposeProxy": false, "advisors": [ &#123; "order": 2147483647, "advice": &#123; &#125;, "pointcut": &#123; "classFilter": &#123; &#125;, "methodMatcher": &#123; "runtime": false &#125; &#125;, "perInstance": true &#125; ], "targetSource": &#123; "target": &#123; "name": "李四", "age": 22, "isBoy": true, "birthday": "2020-01-31T16:00:00.000+0000", "maps": null, "lists": null, "dog": null &#125;, "static": true, "targetClass": "com.sise.jpa.model.Person" &#125;, "targetClass": "com.sise.jpa.model.Person", "preFiltered": false&#125; @ConfigurationProperties与@Value注解的区别 @Configuration @Valye 功能 批量注入配置文件中的属性 一个个指定注入 松散语法 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型注入 支持 不支持 不管是yml配置文件还是properties配置文件，都能获取到配置文件中的值。 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value。 如果说，我们专门编写了一个Bean来和配置文件进行映射，我们就直接使用@ConfigurationProperties。 @PropertyScore与@ImportSource@PropertyScore用来加载指定的配置文件。 只支持.properties文件，不支持.yml文件 如果application.yml或者application.properties中存在与自定义配置文件相冲突的属性，yml或properties的文件优先级高于自定义的配置文件，导致@PropertyScore失效。 12345678910111213141516@Component@Getter@Setter@ToString@PropertySource(value = &#123;"classpath:person.properties"&#125;)@ConfigurationProperties(prefix = "person")public class Person &#123; private String name; private Integer age; private Boolean isBoy; private Date birthday; private Map&lt;String, Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog;&#125; @ImportSource用来导入Spring的配置文件，使配置文件中的内容生效。该注解标注在一个配置类上。 先自己创建一个spring的配置文件。 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="helloService" class="com.sise.jpa.helloService"&gt;&lt;/bean&gt;&lt;/beans&gt; 在SpringBoot的入口类中使用@ImportSource注解： 1234567@SpringBootApplication@ImportResource(locations = &#123;"classpath:spring.xml"&#125;)public class JpaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(JpaApplication.class, args); &#125;&#125; 配置文件属性占位符 使用随机数 1$&#123;random.value&#125;,$&#123;random.int(10)&#125;,$&#123;random.uuid&#125; 占位符获取之前配置的值，如果没有值可以用：指定默认值 1person.dog.name=$&#123;person.name:Tom&#125;_dog Profile 多Profile文件 默认配置文件使用application.properties 我们可以为开发环境和生产环境指定配置文件，文件名可以指定为application-{profile}.properties/yml yml多文档块 每个—分隔的是一个文档块，相当于重新创建一个配置文件。 1234567891011121314151617server: port: 8080spring: profiles: active: dev---server: port: 8081spring: profiles: dev---server: port: 8082spring: profiles: prod 激活指定的配置文件 在主配置文件中指定：值为profile 1spring.profile.active=dev 使用yml多文档块 使用命令行 1java -jar xxx.jar --spring.profiles.active=dev 使用虚拟机参数 虚拟机参数都使用-D开头。 1-Dspring.profiles.active=dev 配置文件的加载位置SpringBoot启动会扫描以下位置的properties/yml文件： 项目路径下/config/ 项目路径下/ classpath/config/ classpath/ 以上是按照优先级从高到低的顺序，所有位置的配置文件都会被加载，高优先级的配置文件内容会覆盖低优先级的配置内容，形成互补配置。 我们也可以通过在启动springBoot项目的时候指定spring.config.location来覆盖默认的配置。 通过指定spring.config.additional-locational来增强默认的配置，与默认配置形成互补。 如果指定了外部的配置文件，则外部配置文件加载顺序优先级比上面四种情况高。 如果在application.properties/yml文件中指定了spring.config.location是无效的。 12java -jar jpa-0.0.1-SNAPSHOT.jar --spring.config.additional-location=C:\Users\zjm16\Desktop\application.yml 自动配置原理 SpringBoot启动的时候加载主配置类，主配置类开启了自动配置功能@EnableAutoConfiguration 1234567@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; @EnableAutoConfiguration作用： 自动扫描与启动类同级的包以及子包 利用AutoConfigurationImportSelector导入一些第三方组件的配置类 1234567891011@Override public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return NO_IMPORTS; &#125; AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader .loadMetadata(this.beanClassLoader); AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); &#125; selectImport中去加载类路径下的资源：(autoconfiguration包i下WEB-INF/spring.factories文件) 1234AutoConfigurationMetadataLoader .loadMetadata(this.beanClassLoader)// 加载的资源的路径protected static final String PATH = "META-INF/spring-autoconfigure-metadata.properties"; spring-autoconfigure-metadata.properties文件中有很多xxxAutoConfiguration的配置类。这些配置类根据条件将需要的组件加入到IOC容器中。 1234org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration=org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration=org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration=org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration= 我们以HttpEncodingAutoConfiguration为例： 1234567891011121314151617181920@Configuration(proxyBeanMethods = false) // 声明这是一个配置类，与@Bean注解一起使用可以向IOC容器中添加组件@EnableConfigurationProperties(HttpProperties.class) // 开启配置文件与实体类的映射@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET) // 条件注解，判断当前是不是web应用，是web应用才将bean添加到IOC容器中。可以看出虽然SpringBoot加载了很多配置类，但只有满足条件的配置类才会被加入到IOC容器当中@ConditionalOnClass(CharacterEncodingFilter.class) // 判断当前CharacterEncodingFilter是否已经存在@ConditionalOnProperty(prefix = "spring.http.encoding", value = "enabled", matchIfMissing = true) // 判断配置文件中是否配置了spring.http.encoding.enabled属性，如果没有配置，设置默认值为truepublic class HttpEncodingAutoConfiguration &#123; private final HttpProperties.Encoding properties; // 可以看到bean中属性来自HttpProperties类，而HttpProperties类的属性与配置文件中的配置形成映射 @Bean @ConditionalOnMissingBean public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; &#125; &#125; HttpProperties： 使用@ConfigurationProperties与配置文件的属性进行关联。配置文件中可配置的属性在HttpProperties类的成员属性能反映出来。 12345@ConfigurationProperties(prefix = "spring.http")public class HttpProperties &#123; private boolean logRequestDetails; private final Encoding encoding = new Encoding();&#125; 精髓： 1）SpringBoot启动会加载大量的自动配置类 2）我们看我们需要的功能有没有SpringBoot默认写好的自动配置类 3）我们再来看这个自动配置类中到底配置了哪些组件（只要有我们需要的组件，我们就不再需要配置了） 4）给容器中自动配置类添加组件的时候，会从ppoperties类中获取某些属性，我们就可以再这些配置文件中指定这些属性的值。 5）xxxxAutoConfiguration自动配置类给容器中添加组件。xxxProperties封装配置文件中相关的属性。 如何查看哪些配置类生效，哪些不生效在配置文件中加入debug=true。这样在启动springBoot项目时，控制台会输出配置类的信息。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ResponseBody.md]]></title>
    <url>%2F2020%2F08%2F10%2FSpringBoot%2Fresponse%E4%B8%8EResponseBody%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[假如说后端想返回一个string类型字符串”你好,SpringBoot”给前端。那么，有以下两种方案: 通过HttpServletResponse对象 1234@GetMapping(value = "test")public void test(HttpServletResponse response) throws IOException &#123; response.getWriter().write("你好 ,SpringBoot！");&#125; 我们通过postman来看一下前端接收到的结果和Header中的值。 当我们用HttpServletResponse返回数据的时候，应该手动设置content-type，编码等。 123456@GetMapping(value = "test")public void test(HttpServletResponse response) throws IOException &#123; response.setHeader("content-type","text/plains"); response.setCharacterEncoding("UTF-8"); response.getWriter().write("你好 ,SpringBoot！");&#125; 当然也可以通过一行代码完成设置: 1response.setHeader("content-type","text/plains;charset=UTF-8"); 这样设置后，返回的结果编码和content-type都正常了。 通过@ResponseBody注解 12345@GetMapping(value = "test")@ResponseBodypublic String test() &#123; return "你好，SpringBoot";&#125; 从结果来看，@responseBody会自动帮我们设置content-type和编码： 以上返回的是字符串，那如果返回的是一个Object呢？ 12345678@GetMapping(value = "test")@ResponseBodypublic Map&lt;String,Object&gt; test() &#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("id","1"); map.put("name","王小喵"); return map;&#125; 我们来看一下返回结果会是什么? 可以看到，@ResponseBody注解自动添加了content-type，还将对象自动转换成了json格式 总结： 使用@ResponseBody来代替HttpServletResponse。HttpServletResponse需要自己设置编码等很多属性，而@ResponseBody会自动帮我们回写content-type、编码等值]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注解.md]]></title>
    <url>%2F2020%2F08%2F10%2FJava%2F%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[概念注解：说明程序的，给计算机看的。 注释：用文字描述程序的，给程序员看的。 作用 编写文档：通过代码里标识的注解生成javadoc文档 代码分析：通过代码里标识的注解对代码进行分析【使用反射】 编译检查：能够实现基本的编译检查【@Override】 基本的内置注解@Override：检测被该注解标注的方法是否是继承父类(父接口) @Deprecated：该注解标注的内容已过时，别人调用编译器会提示 @SupressWarnings：压制警告，一般使用参数all。@SupressWarnings(“all”) 自定义注解 格式： 12元注解public @interface xxx&#123;&#125; 本质：本质上就是一个接口，该接口默认继承Annotation接口 1public interface xxx extends java.lang.annotation.Annotation 属性：接口中的抽象方法 属性的返回值类型只能是： ​ 1.基本类型 ​ 2.String ​ 3.Enum ​ 4.注解 ​ 5.以上类型的数组 定义了属性，在使用的时候要赋值 ​ 1.如果使用default关键字给默认值，则使用注解时，可以不进行属性的赋值 ​ 2.如果只有一个属性，并且属性的名称是value，则value可以省略，直接定义即可 ​ 3.数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略 元注解 @Target：描述注解能够作用的位置(类，方法，变量等) ElementType取值： ​ TYPE：可以作用于类上 ​ METHOD：可以作用于方法上 ​ FIELD：可以作用于成员变量上 @Retention：描述注解被保留的阶段 RetentionPoliy取值： ​ SOURCE：不会被保留在class字节码文件中 ​ RUNTIME：当前被描述的注解会保留到class字节码文件中，并被JVM读取到。自定义注解一般使用该值 ​ CLASS：会保留到class字节码文件中，但是不会被JVM读到 @Documented：描述注解是否被抽取到javadoc文档中 @Inherited：描述注解是否被继承 获取注解中定义的属性值1.获取注解定义的位置的对象(Class，Method，Field) 2.获取该对象上指定的注解(getAnnotation(class)) 3.获取注解中抽象方法获取配置的属性值]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>注解,JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改路由前缀.md]]></title>
    <url>%2F2020%2F08%2F10%2FSpringBoot%2F%E4%BF%AE%E6%94%B9%E8%B7%AF%E7%94%B1%E5%89%8D%E7%BC%80%2F</url>
    <content type="text"><![CDATA[假如我们想用SpringBoot自动为我们生成路由前缀，且指定一个包名后，springBoot生成的前缀会加上包名下的目录。比如包名为com.sise.ming.api.v1.BannerController。我们希望指定一个api-package=com.sise.ming.api后，springBoot自动将我们的路由映射为/v1/banner。 实现这个功能需要修改SpringBoot的源码。需要继承RequestMappingHandlerMapping，且实现getMappingForMethod方法，将其返回的RequestMappingInfo修改为我们自己的RequestMappingInfo。 12345678910111213141516171819202122232425262728293031323334353637public class AutoPrefixUrlMapping extends RequestMappingHandlerMapping &#123; @Value("$&#123;api-package&#125;") private String apiPackage; @Override protected RequestMappingInfo getMappingForMethod(Method method, Class&lt;?&gt; handlerType) &#123; RequestMappingInfo requestMappingInfo = super.getMappingForMethod(method, handlerType); if (requestMappingInfo != null) &#123; String prefix = this.getPrefixUrl(handlerType); return RequestMappingInfo.paths(prefix).build().combine(requestMappingInfo); &#125; return requestMappingInfo; &#125; /** * get requestMapping package name and replace prefix * * @param handlerType the handlerType of requestMapping * @return thr prefix of package name */ private String getPrefixUrl(Class&lt;?&gt; handlerType) &#123; String packageName = handlerType.getPackage().getName(); // replace package prefix to empty string String dotPath = packageName.replaceAll(this.apiPackage, ""); dotPath = dotPath.replace(".", "/"); return dotPath; &#125; public String getApiPackage() &#123; return apiPackage; &#125; public void setApiPackage(String apiPackage) &#123; this.apiPackage = apiPackage; &#125;&#125; 那么SpringBoot怎么知道我们生成这个类呢？我们需要将它加入到IOC容器中。这里采用的是配置类，定义一个配置类实现WebMvcRegistrations接口，并将配置类加入到IOC容器中。 1234567@Componentpublic class AutoPrefixUrlConfiguration implements WebMvcRegistrations &#123; @Override public RequestMappingHandlerMapping getRequestMappingHandlerMapping() &#123; return new AutoPrefixUrlMapping(); &#125;&#125; 配置文件： 1api-package = com.sise.ming.api controller： 123@RestController@RequestMapping("/banner")public class BannerController &#123;...&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>修改路由前缀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加载第三方组件.md]]></title>
    <url>%2F2020%2F08%2F10%2FSpringBoot%2F%E5%8A%A0%E8%BD%BD%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[我们平常开发写的@Compone将类加入到IOC容器中，主要针对的是业务类。如果想把第三方的jar包中的类加入到IOC容器中，应该怎么操作呢？ 在@SpringBootApplication注解中有一个@EnableAutoConfiguration。这是导入第三方jar包的关键 在@EnableAutoConfiguration中，@import了一个select类。 在这个select类中加载了一个.factories的文件。这个文件配置了所有要导入IOC容器的类。如果第三方想把类加入到IOC容器中，那么jar包提供者应该提供一个.factories的文件，里面包含了所有要导入IOC容器的类。 如何自定义一个启动类来验证AutoConfiguration的机制？ 123456789101112//@ComponentScan@Import(Config.class)public class LOLApplication &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext context = new SpringApplicationBuilder(LOLApplication.class) .web(WebApplicationType.NONE) .run(args); Connect connect = (Connect) context.getBean("mysql"); connect.connect(); &#125;&#125; 自定义的启动类如果加上@ComponentScan，会扫描与启动类同级目录和子目录下的bean，将其加入到IOC容器中。刚好这里Config配置类在扫描路径中，所以加上@ComponentScan可以启动服务器。 如果使用@Import来导入配置类，则会缺少很多@SpringBootApplication默认的配置。启动服务器会报错。第7行代码就是解决单独导入配置类引起的错误。 源码中@Import的是一个Select的类，我们也来实现一下。实现创建一个类实现ImportSelector接口。 方法的返回值是一个字符串数组，数组的元素就是需要导入的配置类的类名。这里可以使用class.getName() 123456public class LOLSelector implements ImportSelector &#123; @Override public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; return new String[] &#123;Config.class.getName()&#125;; &#125;&#125; 接着启动类可以import我们编写好的Selector。但是源码中使用的是@EnabledAutoConfiguration，我们也来还原一下。 首先编写一个注解，导入Selector配置类。 12345@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Import(LOLSelector.class)public @interface EnabledAutoConfiguration &#123;&#125; 接着在启动类就可以直接使用@EnabledAutoConfiguration了。 1234567891011@EnabledAutoConfigurationpublic class LOLApplication &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext context = new SpringApplicationBuilder(LOLApplication.class) .web(WebApplicationType.NONE) .run(args); Connect connect = (Connect) context.getBean("mysql"); connect.connect(); &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>加载第三方组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义异常体系.md]]></title>
    <url>%2F2020%2F08%2F10%2FSpringBoot%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[自定义异常体系在我们的日常开发中非常重要。一方面为了让用户体验更好，应该在发生异常的时候，在前端页面显示出错误信息。而另一方面，应该隐藏后端的异常，因为后端出现的异常对于前端开发者和用户来说毫无意义。所以，我们需要定义一种统一返回给前端的异常格式。 我们先明确两个概念：未知异常，已知异常 在开发过程中，我们有时会手动抛出一个异常，举个栗子： 12345public String test(String id) &#123; if (id == null)&#123; throw new RuntimeException(10001); &#125; &#125; 像这种参数为空抛出异常，这是我们程序员可以预知的异常，就称为已知异常。但是我们程序员不可能捕获所有的异常，而那些未捕获而在运行期间抛出的异常，我们就称为未知异常。 我们可以使用SpringBoot的全局异常处理。无论在程序中抛出什么异常，最终都会经过全局异常处理后才返回给前端。这样，我们就可以在全局异常处理中统一返回给前端的异常格式。 首先，我们先来定义统一返回信息类。这里的getter和setter方法非常重要。 123456789101112131415161718192021222324252627282930313233public class UnifyResponse &#123; private Integer code; private String message; private String request; private String method; public UnifyResponse(Integer code, String message, String request,String type) &#123; this.code = code; this.message = message; this.request = request; this.method = type; &#125; public Integer getCode() &#123; return code; &#125; public String getMessage() &#123; return message; &#125; public String getRequest() &#123; return request; &#125; public String getMethod() &#123; return method; &#125; public void setMethod(String method) &#123; this.method = method; &#125;&#125; 全局异常处理需要@ControllerAdvice和@ExceptionHandler： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@ControllerAdvicepublic class GlobalExceptionAdvice &#123; @Autowired private ExceptionCodeConfiguration exceptionCodeConfiguration; /** * handler unknown exception * * @param request the request of http * @param e the exception that method throw * @return the unify response message */ @ExceptionHandler(Exception.class) @ResponseBody @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) public UnifyResponse handlerException(HttpServletRequest request, Exception e) &#123; Map&lt;String, String&gt; requestInfo = this.getRequestUrlAndMethod(request); return new UnifyResponse(9999, "服务器内部错误", requestInfo.get("url"), requestInfo.get("method")); &#125; /** * handler already known exception * * @param request the request of http * @param e the exception that method throw * @return the unify response message */ @ExceptionHandler(HttpException.class) public ResponseEntity&lt;UnifyResponse&gt; handlerHttpException(HttpServletRequest request, HttpException e) &#123; Map&lt;String, String&gt; requestInfo = this.getRequestUrlAndMethod(request); // header HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); // http status HttpStatus httpStatus = HttpStatus.resolve(e.getHttpStatusCode()); // message Integer code = e.getCode(); System.out.println(e); String message = exceptionCodeConfiguration.getMessage(code); UnifyResponse unifyResponse = new UnifyResponse(code, message, requestInfo.get("url"), requestInfo.get("method")); return new ResponseEntity&lt;&gt;(unifyResponse, headers, httpStatus); &#125; /** * get http request information * * @param request the request of http * @return the map of request information */ private Map&lt;String, String&gt; getRequestUrlAndMethod(HttpServletRequest request) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(2); map.put("url", request.getRequestURI()); map.put("method", request.getMethod()); return map; &#125;&#125; 介绍一下这里的两个方法： 1234@ExceptionHandler(Exception.class)@ResponseBody@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)public UnifyResponse handlerException(HttpServletRequest request, Exception e) 这是处理”未知异常”的处理方法。方法的参数是Exception。因为未知异常我们是无法预知错误码的，这里我们定义为9999。同样，返回给前端的消息固定为”服务器内部错误“。因为返回的是一个对象，需要@ResponseBody注解。@HttpStatus返回HTTP的状态码。 12@ExceptionHandler(HttpException.class)public ResponseEntity&lt;UnifyResponse&gt; handlerHttpException(HttpServletRequest request, HttpException e) 这是处理”已知异常“的处理方法。方法的参数是我们自定义的HttpException。由于message和httpStatus是动态决定的，所以返回的ResponseEntity，且不需要使用@ResponseBody。message和httpStatus的信息，我们要从自定义异常中获取。而没有使用@ResponseBody，我们需要在header中手动设置content-Type的值。 接下来介绍下自定义异常类： 123456789101112public class HttpException extends RuntimeException &#123; protected Integer code; protected Integer httpStatusCode = 500; public Integer getCode() &#123; return code; &#125; public Integer getHttpStatusCode() &#123; return httpStatusCode; &#125;&#125; 1234567public class NotFoundException extends HttpException &#123; public NotFoundException(Integer code)&#123; this.code = code; this.httpStatusCode = 404; &#125;&#125; 自定义配置异常类： 123456789101112131415161718192021@ConfigurationProperties(value = "ming")@PropertySource(value="classpath:config/exception-code.properties")@Componentpublic class ExceptionCodeConfiguration &#123; private Map&lt;Integer,String&gt; codes = new HashMap&lt;&gt;(16); public String getMessage(Integer code)&#123; return codes.get(code); &#125; public Map&lt;Integer, String&gt; getCodes() &#123; return codes; &#125; public void setCodes(Map&lt;Integer, String&gt; codes) &#123; this.codes = codes; &#125;&#125; @PropertySource关联了配置文件，而@ConfigurationProperties设置了配置文件中key的前缀，而成员变量codes对应者配置文件中的key值。 配置文件： 12ming.codes[10000] = 通用错误ming.codes[10001] = 通用参数错误 这里的前缀是不能少的，不然注入会失败。而且这里的字符串不需要加”“，否则返回前端的信息中也会带有引号。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列化工具类.md]]></title>
    <url>%2F2020%2F08%2F10%2FSpringBoot%2F%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[当我们在数据表中存储的是json字符串的时候，映射到实体类的时候，Java中只有String类型能和json字符串对应。 那么，如果我们想把json字符串反序列化成对象,有什么办法嘛？ 利用Getter、Setter方法 在序列化、反序列化的时候，都要调用实体类的利用Getter、Setter方法，我们可以利用这个特点，在Getter方法中进行反序列化，在Setter方法中进行序列化。当然，序列化的方法可以使用Jackson或者FastJson。 缺点： 如果某个类中有需要序列化、反序列化的属性，那就得修改这个类的Getter、Setter方法，无法做到通用。 有一种观点认为不应该在实体类中写业务逻辑 利用JPA的Converter 我们利用JPA的converter，并在实体类中指定要使用的converter，达到序列化和反序列化的效果。 可以将实体的属性反序列化为Map&lt;String,Object&gt;和List这种数据结构，也可以反序列化为一个具体的实体类。我们以HashMap来举一个栗子。 编写converter需要实现AttributeConverter&lt;T,K&gt;接口，T是转换后的数据类型，K是转换前的数据类型 需要加上@Converter注解 序列化主要调用writeValueAsString方法，反序列化主要调用readValue方法 123456789101112131415161718192021222324252627282930313233@Converterpublic class MapAndJson implements AttributeConverter&lt;Map&lt;String, Object&gt;, String&gt; &#123; @Autowired private ObjectMapper objectMapper; @Override public String convertToDatabaseColumn(Map&lt;String, Object&gt; attribute) &#123; try &#123; if (attribute == null || attribute.isEmpty()) &#123; return ""; &#125; return objectMapper.writeValueAsString(attribute); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); throw new ServerErrorException(9999); &#125; &#125; @Override @SuppressWarnings("unchecked") public Map&lt;String, Object&gt; convertToEntityAttribute(String dbData) &#123; try &#123; if (StringUtils.isBlank(dbData)) &#123; return null; &#125; return objectMapper.readValue(dbData, HashMap.class); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); throw new ServerErrorException(9999); &#125; &#125;&#125; 实体类中使用@convert注解标明要使用的converter。 12@Convert(converter = MapAndJson.class) private Map&lt;String,Object&gt; specs; 缺点： 使用Map和List这种结构，无法调用业务类的方法。例如List可以调用Spec这个类的业务方法。而使用List无法调用类的业务方法。 如果有多个实体类需要序列化、反序列化，需要编写多个Converter 我们追求一种通用的写法，可不可以利用泛型呢？ 上面的Converter方法中可以使用泛型来达到一种通用的效果，但是Java中泛型是有缺点的。主要体现在反序列化的第二个参数，如果直接使用T.class是不行的。所以我们需要一种机制可以将Class传入到Converter中，但是JPA的Converter无法做到这一点。 1return objectMapper.readValue(dbData, HashMap.class); 我们尝试自己编写一个工具类来实现序列化和反序列化的功能。这样就可以通过传参的方式传入Class。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091@Componentpublic class GenericAndJson&lt;T&gt; &#123; private static ObjectMapper objectMapper; @Autowired public void setObjectMapper(ObjectMapper objectMapper) &#123; GenericAndJson.objectMapper = objectMapper; &#125; /** * 序列化 * * @param o 需要转换成json字符串的对象 * @param &lt;T&gt; 目标对象类型 * @return json字符串 */ public static &lt;T&gt; String objectToJson(T o) &#123; if (o == null) &#123; return ""; &#125; try &#123; return GenericAndJson.objectMapper.writeValueAsString(o); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); throw new ServerErrorException(9999); &#125; &#125; /** * 反序列化 * * @param s json字符串 * @param type typeReference对象 * @param &lt;T&gt; 目标对象类型 * @return 转换后的目标对象 */ @SuppressWarnings("unchecked") public static &lt;T&gt; T jsonToObject(String s, TypeReference&lt;T&gt; type) &#123; if (StringUtils.isBlank(s)) &#123; return null; &#125; try &#123; return GenericAndJson.objectMapper.readValue(s, type); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); throw new ServerErrorException(9999); &#125; &#125; /** * json字符串转换成List * * @param s json字符串 * @param &lt;T&gt; 目标对象类型 * @return 转换后的目标对象 */ /* public static &lt;T&gt; List&lt;T&gt; jsonToList(String s) &#123; if (StringUtils.isBlank(s)) &#123; return Collections.emptyList(); &#125; try &#123; List&lt;T&gt; list = GenericAndJson.objectMapper.readValue(s, new TypeReference&lt;List&lt;T&gt;&gt;() &#123; &#125;); return list; &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); throw new ServerErrorException(9999); &#125; &#125;*/ /** * json字符串转换成List(需要传入TypeReference) * @param s json字符串 * @param type typeReference对象 * @param &lt;T&gt; 目标对象类型 * @return 转换后的目标对象 */ /*public static &lt;T&gt; T jsonToList(String s, TypeReference&lt;T&gt; type) &#123; if (StringUtils.isBlank(s)) &#123; return null; &#125; try &#123; return GenericAndJson.objectMapper.readValue(s, type); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); throw new ServerErrorException(9999); &#125; &#125;*/&#125; 这里因为注入了ObjectMapper对象，所以需要加上@Component注解。同时，这里还巧妙的利用了setter方法注入static的对象。 同时，在实体类中需要使用Getter、Setter方法来处理。 12345678910111213141516171819202122232425262728// ...省略private String specs;/** * 数据库中获取的字符串对象反序列化 * * @return 反序列化后的对象 */ public List&lt;Spec&gt; getSpecs() &#123; if (StringUtils.isBlank(this.specs)) &#123; return Collections.emptyList(); &#125; return GenericAndJson.jsonToObject(this.specs, new TypeReference&lt;List&lt;Spec&gt;&gt;() &#123; &#125;); &#125; /** * 序列化对象保存到数据库 * * @param specs 对象 * @return json字符串 */ public String setSpecs(List&lt;Spec&gt; specs) &#123; if (specs == null || specs.isEmpty()) &#123; return ""; &#125; return GenericAndJson.objectToJson(specs); &#125; 上面的工具类是比较通用的工具类，但是还不够好。 缺点： 需要使用TypeReference来传入参数 注释掉的方法是对不需要传入TypeReference所做的尝试。 一种思路是把List当成一个泛型T 一种思路是把List中的T当成一个泛型T。这种方法看似可行，但是DEBUG发现，传入的实体类并没有生效，而是使用了LinkedHashMap来实现的，这就达不到可以调用实体类的业务方法的期望。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>序列化，工具类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动配置.md]]></title>
    <url>%2F2020%2F08%2F10%2FSpringBoot%2F%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[我们运行启动类就可以运行项目，那么SpringBoot是怎么自动配置的呢？ 我们从SpringBoot的入口类开始分析。入口类有@SpringBootApplication注解。点击进去： 12345678@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;) SpringBoot自动配置的核心注解是@EnableAutoConfiguration。点击进去： 123456@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class) @AutoConfigurationPackage： 12345678@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Import(AutoConfigurationPackages.Registrar.class)public @interface AutoConfigurationPackage &#123;&#125; 可以看到上面的注解导入了一个类，这个类调用了getPackageName()方法。通过debug调试可以知道，这个packageName是SprinGBoot启动类同级目录的包名。换句话说，SpringBoot会自动扫描与启动类同级包以及子包的所有类。 1234@Override public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123; register(registry, new PackageImport(metadata).getPackageName()); &#125; 接下来看@EnableAutoConfiguration还导入了另外一个类：@Import(AutoConfigurationImportSelector.class) selectImports方法返回一个String数组，该数组包含了配置类的全限定名。通过获取配置类的全限定名，来将类导入IOC容器，从而实现自动配置。 1234567891011@Overridepublic String[] selectImports(AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return NO_IMPORTS; &#125; AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader .loadMetadata(this.beanClassLoader); AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());&#125; 那么，这些配置类的全限定名是从哪里来的呢？可以看到加载了一个配置文件： 1234final class AutoConfigurationMetadataLoader &#123; protected static final String PATH = "META-INF/spring-autoconfigure-metadata.properties";&#125; 配置文件的内容：可以看到配置文件中是各种jar包的配置类]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件复制.md]]></title>
    <url>%2F2020%2F08%2F10%2F%E7%BD%91%E7%BB%9C%2F%E5%9B%9B%E7%A7%8D%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[四种复制文件的方法 字节复制 缓冲流复制 使用Buffer的FileChanel 直接使用FileChannel 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/** * @作者 ming * @目标 当你的才华还撑不起你的野心时，就应该静下心来学习； * 当你的能力还驾驭不了你的目标时，就应该沉下心来历练； * 梦想不是浮躁，而是沉淀和积累。 * @创建时间 2020/8/9 14:29 */package filecopy;import java.io.*;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;public class FileCopyTest &#123; public static void close(Closeable closeable) &#123; if (closeable != null) &#123; try &#123; closeable.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; FileCopyRunner runner1 = (source, target) -&gt; &#123; InputStream fin = null; OutputStream fout = null; try &#123; fin = new FileInputStream(source); fout = new FileOutputStream(target); int size = 0; while ((size = fin.read()) != -1) &#123; fout.write(size); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; close(fin); close(fout); &#125; &#125;; long startTime = System.currentTimeMillis(); File sourceFile1 = new File("D:\\IDEA Pro\\sockets\\src\\filecopy\\test.doc"); File targetFile1 = new File("D:\\IDEA Pro\\sockets\\src\\filecopy\\runner1.doc"); runner1.copyFile(sourceFile1, targetFile1); System.out.println("runner1总耗时:" + (System.currentTimeMillis() - startTime)); FileCopyRunner runner2 = (source, target) -&gt; &#123; InputStream fin = null; OutputStream fout = null; try &#123; fin = new BufferedInputStream(new FileInputStream(source)); fout = new BufferedOutputStream(new FileOutputStream(target)); byte[] buffer = new byte[1024]; while ((fin.read(buffer)) != -1) &#123; fout.write(buffer, 0, buffer.length); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; close(fin); close(fout); &#125; &#125;; startTime = System.currentTimeMillis(); File sourceFile2 = new File("D:\\IDEA Pro\\sockets\\src\\filecopy\\test.doc"); File targetFile2 = new File("D:\\IDEA Pro\\sockets\\src\\filecopy\\runner2.doc"); runner1.copyFile(sourceFile2, targetFile2); System.out.println("runner2总耗时:" + (System.currentTimeMillis() - startTime)); FileCopyRunner runner3 = (source, target) -&gt; &#123; FileChannel fin = null; FileChannel fout = null; try &#123; fin = new FileInputStream(source).getChannel(); fout = new FileOutputStream(target).getChannel(); ByteBuffer buffer = ByteBuffer.allocate(1024); while (fin.read(buffer) != -1) &#123; // 切换为写模式 buffer.flip(); while (buffer.hasRemaining()) &#123; fout.write(buffer); &#125; // 切换为读模式 buffer.clear(); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; close(fin); close(fout); &#125; &#125;; startTime = System.currentTimeMillis(); File sourceFile3 = new File("D:\\IDEA Pro\\sockets\\src\\filecopy\\test.doc"); File targetFile3 = new File("D:\\IDEA Pro\\sockets\\src\\filecopy\\runner3.doc"); runner1.copyFile(sourceFile3, targetFile3); System.out.println("runner3总耗时:" + (System.currentTimeMillis() - startTime)); FileCopyRunner runner4 = (source, target) -&gt; &#123; FileChannel fin = null; FileChannel fout = null; try &#123; fin = new FileInputStream(source).getChannel(); fout = new FileOutputStream(target).getChannel(); long totalSize = 0; while (totalSize != fin.size()) &#123; totalSize += fin.transferTo(0, fin.size(), fout); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; close(fin); close(fout); &#125; &#125;; startTime = System.currentTimeMillis(); File sourceFile4 = new File("D:\\IDEA Pro\\sockets\\src\\filecopy\\test.doc"); File targetFile4 = new File("D:\\IDEA Pro\\sockets\\src\\filecopy\\runner4.doc"); runner1.copyFile(sourceFile4, targetFile4); System.out.println("runner4总耗时:" + (System.currentTimeMillis() - startTime)); &#125;&#125;]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>文件复制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[应对变化的两种方案.md]]></title>
    <url>%2F2020%2F08%2F10%2F%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%2F%E5%BA%94%E5%AF%B9%E5%8F%98%E5%8C%96%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[变化是使得代码不稳定的本质问题。为了应对变化，通常有两种解决方案： 1.策略模式 2.属性配置、配置文件 所谓的策略模式就是实现一个接口，有多个实现类。根据不同的情况来切换不同的实现类。 所谓的配置文件，就是将代码中经常变化的部分抽出来放在配置文件，通过修改配置文件来应对变化。 策略模式应对变化的几种方案： 1.通过byname注入，通过切换bean name 2.@Qualiier 指定bean 3.有选择地只注入一个bean，注释掉某个bean上的@Compoent注解 4.使用@Primary注解 5.@Conditional注解]]></content>
      <categories>
        <category>思想</category>
      </categories>
      <tags>
        <tag>思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向抽象编程.md]]></title>
    <url>%2F2020%2F08%2F10%2F%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%2F%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[在编程过程中啊，很多时候我们是用面向对象的思想编程。这是我们在编程过程中很自然就会去应用的思想。比如我们来模拟一下英雄联盟这个游戏的应用场景。 现在呢，我们有一个需求：当用户输入一个英雄的名称后，释放英雄的一个技能。 面对这个需求，首先我们很容易想到把英雄这个类抽象出来，创建一个对象。 123456789101112public class Diana &#123; public void Q()&#123; System.out.println("Diana Q"); &#125; public void W()&#123; System.out.println("Diana W"); &#125; public void E()&#123; System.out.println("Diana E"); &#125; public void R()&#123; System.out.println("Diana R"); &#125;&#125; 创建好了对象，我们就应该去使用它。大多数情况下，我们是去调用它的方法。 123456789101112131415161718192021222324252627public class Main &#123; public static void main(String[] args) &#123; String name = Main.acceptPleyerInput(); String name = Main.acceptPleyerInput(); switch (name)&#123; case "Diana": Diana diana = new Diana(); diana.R(); break; case "Yasoo": Yasoo yasoo = new Yasoo(); yasoo.R(); break; case "Ez": Ez ez = new Ez(); ez.R(); &#125; &#125; public static String acceptPleyerInput()&#123; System.out.println("please enter a hero name"); Scanner scanner = new Scanner(System.in); return scanner.nextLine(); &#125;&#125; 代码中的第6行，当我们需要使用到Diana这个对象的时候，我们就会去创建它。但是仔细一想，这样直接new对象真的好么？实现需求肯定是能实现的，但这不是我们追求的目标，我们的目标是不仅实现需求，还追求代码的可维护性。试想，如果有一天Diana这个字符串对应的不再是Diana这个对象了，那么我们是不是需要去修改第6行的代码，去创建别的对象？在代码量少，业务简单的情况下，你可能觉得还好，改了就改了呗。但是一旦这个类被多个类所调用呢？是不是就得在每一个使用了Diana对象的类中进行修改？这样是不是很难维护呢？ 所以，我们提出一个概念：不要面向具体的对象编程，要面向抽象编程。那么问题来了，有什么办法可以让我们更好的去面向抽象编程呢？ interface、abstract 工厂模式 IOC / DI 我们先来看第一种：使用interface 先定义一个Hexo接口，所有的英雄类实现这个接口。 123456public interface Hero &#123; void Q(); void W(); void E(); void R();&#125; 在使用了接口之后，我们还是需要new出每个对象，而且也没有优化掉switch..case..，那么，我们为什么还要抽象出接口呢？这里给出结论：单纯地使用interface能统一方法的调用，但无法统一对象的实例化。相比较第一版的代码，原本在switch..case..中的方法调用优化了，但是switch..case..没有优化掉。仔细分析，这里的switch..case..正是执行了对象的实例化，正好印证了结论。 123456789101112131415161718public static void main(String[] args) &#123; String name = Main.acceptPleyerInput(); Hero hero = null; switch (name) &#123; case "Diana": hero = new Diana(); break; case "Yasoo": hero = new Yasoo(); break; case "Ez": hero = new Ez(); break; default: throw new RuntimeException(); &#125; hero.R(); &#125; 那么，只是简化了方法的调用，意义大吗？ 当然了，如果有很多个英雄呢？那岂不是要调用很多次R()吗？所以，统一方法的调用还是很有意义的。 从上面的分析，interface可以解决的是方法统一调用的问题，其实，抽象的难点在于new对象的优化。只有一段代码中没有new的出现，才能保持代码的相对稳定，才能逐步实现OCP(开闭原则)。而对象的实例化是不可能消除的，只能将它实例化的过程转移到其他的代码片段中。接下来，我们就利用简单工厂模式来转移对象的实例化代码。 首先，我们创建一个工厂，该工厂用来产生Hero的对象 12345678910111213141516171819public class BeanFactory &#123; public static Hero getHero(String name)&#123; Hero hero; switch (name) &#123; case "Diana": hero = new Diana(); break; case "Yasoo": hero = new Yasoo(); break; case "Ez": hero = new Ez(); break; default: throw new RuntimeException(); &#125; return hero; &#125;&#125; 有了工厂之后，我们不再需要在main方法中使用switch..case..了。这段代码利用interface+工厂模式，已经将对象的实例化分离到工厂中，对main方法来说，它就是稳定的一段代码了吗？不一定，稳定是相对的。这段代码虽然分离了对象的实例化代码，但是它是巧妙地利用了BeanFactory的静态方法。假如BeanFactory不是静态的了，那么调用getHero()就需要变化。从另外一个角度来说，我们实现了与具体对象(通过new出来的对象)的低耦合，但是我们耦合了工厂对象。 12345public static void main(String[] args) &#123; String name = Main.acceptPleyerInput(); Hero hero = BeanFactory.getHero(name); hero.R(); &#125; 在使用了interface+简单工厂模式后，main方法已经是相对稳定的了。但是代码中总是会存在不稳定，我们要做的是隔离这些不稳定的代码，使其他代码相对稳定。假如这个BeanFactory能生产出任何的对象，那我们岂不是就不用修改main方法里的BeanFactory了吗，因为无论什么样的对象，工厂都能生产出来。其实，这就类似于Spring中ApplicationContext。 在这里停下来想一想，到底是什么导致了代码的不稳定呢？主要是两个方面： 1.用户的输入信息变化了，这和本例是一致 2.用户的需求变化了 假如说用户输入的不再是英雄的名字(字符串)，而是能直接输入一个对象的话，那我们就消除了new对象，从而消除了switch..case…其实这在java中是可以利用反射实现的，只不过要求用户输入的必须是带上包名的完整的类的名称。 12345678910public class BeanFactory &#123; public static Hero getHero(String name) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123; // 完整的类名称 name = "v1." + name; // 通过反射创建对象 Class&lt;?&gt; clazz = Class.forName(name); Object obj = clazz.newInstance(); return (Hero) obj; &#125;&#125; 我们利用了反射消除了switch..case这种根据用户输入字符串new对象的方式。但是要注意的是，我们需要对用户输入的字符串进行处理，处理成完整的类的名称。当用户输入字符串后，就相当于我们拿到了对应的对象。这里就类似于Spring中利用配置文件来反射对象。 上面的代码，我们利用了静态的BeanFactory，实际上已经实现了OCP原则。但唯一遗憾的是，如果BeanFactory变动了(比如原来的getHero方法改变了)，那我们还是需要修改main方法的。那有什么办法再把BeanFactory分离出去，更好地实现OCP原则吗？方法是有的，那就是Spring的IOC。在之前的代码中，我们都是主动地去要，主动地调用BeanFactory的方法。一旦改变，就会违反OCP。而使用Spring的IOC，我们是被动地接收，不再主动地去要。这样就分离了BeanFactory，也就使得OCP更加稳定，这就是所谓的控制反转。反转的是资源(不仅仅只是包括对象)的获取途径，从主动获取反转为被动接收。 新的问题又出现了？怎么被动接收呢？通过方法传参? 这就涉及到了另外一个概念———依赖注入(DI)，通常我们是在类的层面注入。就比如这里的main方法，虽然是在main方法中使用，但是通常是在main方法这个类中注入BeanFactory，这样main方法也可以去调用。 常用的两种依赖注入的方法： 1.属性注入 2.构造器注入]]></content>
      <categories>
        <category>思想</category>
      </categories>
      <tags>
        <tag>思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Autowaired.md]]></title>
    <url>%2F2020%2F08%2F10%2FSpringBoot%2FBean%2FAutowired%2F</url>
    <content type="text"><![CDATA[面向抽象的编程，通常，我们会在类中定义接口，而注入的是接口的实现类。 举个栗子： 12345678910111213@RestController@RequestMapping("/v1/banner")public class BannerController &#123; @Autowired private Skill diana; @GetMapping(value = "test") public String test() &#123; diana.R(); return "ok"; &#125;&#125; 这里的Skill是接口。如果它有两个实现类Diana和Itera，那么到底哪个实现类会被注入呢？ 注入的时候可能会发生的几种情况： 1.找不到任何一个bean ，报错 2.只找到一个bean，直接注入 3.找到多个bean，并不一定会报错，按照字段名字推断选择哪个bean 其实，总结起来就是两种方式： 1.通过类型注入 2.通过name注入 通过类型注入的优先级 &gt; 通过name注入。@Autowaired默认是通过类型注入。 当注入Skill的实现类时，发现了有多个实现类，此时通过类型注入不能决定应该注入哪个实现类。 既然通过类型决定不了，就会通过字段名去推断要注入哪个类。而这种通过类型和name的注入是被动地注入，我们也可以使用@Qualify(“diana”)来指明主动地注入某一个实现类。 123@Autowired @Qualifier("itrea") private Skill diana; 即使这里的字段名是diana，而我们使用了@Qualify主动注入了itera。最终注入的实现类还是itrea，调用的方法还是itrea的方法。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Configuration.md]]></title>
    <url>%2F2020%2F08%2F10%2FSpringBoot%2FBean%2FConfiguration%2F</url>
    <content type="text"><![CDATA[@Configuration也是一个将bean加入到IOC容器的注解。那么它和其他的模式注解有什么区别吗？ 其他的模式注解只能将一个类加入到IOC容器，也能通过配置文件修改类的属性。但是它的缺点是不能应对一个接口有多个实现类的变化。假如需要注入的是另外的一个实现类，就很难实现了。 而@Configuration与@Bean的配合使用，不仅能通过配置文件修改类的属性，还能在将类加入到IOC容器前做一些逻辑处理。这种方式不仅可以应该属性带来的变化，还能通过条件注解来应对注入不同实现类的变化。 举个栗子： 比如现在有一个Connect接口，其有两个实现类MySql和Oracle。两个实现类都有各自的host和port属性。 123public interface Connect &#123; void connect();&#125; 123456789101112131415public class MySql implements Connect &#123; private String host; private Integer port; public MySql(String host, Integer port) &#123; this.host = host; this.port = port; &#125; @Override public void connect() &#123; System.out.println(this.host + ":" + this.port); &#125;&#125; 123456789101112131415public class Oracle implements Connect &#123; private String host; private Integer port; public Oracle(String host, Integer port) &#123; this.host = host; this.port = port; &#125; @Override public void connect() &#123; System.out.println(this.host + ":" + this.port); &#125;&#125; 现在要将Mysql注入到IOC容器中，使用传统的模式注解和@Configuration都是可以完成的，也可以通过配置文件注入属性。 12345678910111213@Configurationpublic class Config &#123; @Value("$&#123;mysql.host&#125;") private String host; @Value("$&#123;mysql.port&#125;") private Integer port; @Bean public Connect init()&#123; return new MySql(this.host,this.port); &#125;&#125; 假如现在需要注入的是Oracle的实现类，那么传统的模式注解就无法完成了。而@Configuration可以通过条件注解注入不同的实现类。 总结：@Configuration将bean加入IOC的方式更加灵活，它可以做逻辑处理，也可以一起注入多个Bean。它通过条件注解和配置文件注入属性，能够应对两种情况所带来的变化。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Conditional.md]]></title>
    <url>%2F2020%2F08%2F10%2FSpringBoot%2FBean%2FConditional%2F</url>
    <content type="text"><![CDATA[条件注解可以解决策略模式多种实现类的问题。 使用自定义条件注解需要自己编写一个类实现conidtion接口，并在配置类中使用@conditional注解。 12345@Bean @Conditional(DatabaseCondition.class) public Connect mysql()&#123; return new MySql(this.host,this.port); &#125; 也可以使用spring自带的条件注解： 12345@Bean @ConditionalOnProperty(value = "database",havingValue = "mysql",matchIfMissing = true) public Connect mysql()&#123; return new MySql(this.host,this.port); &#125; value的值是配置文件中的key。matchIfMissing相当于默认值。当在配置文件中找不到database的配置项时，默认将MySql这个类加入到IOC容器中。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JOIN方法.md]]></title>
    <url>%2F2020%2F08%2F10%2F%E5%B9%B6%E5%8F%91%2F%E5%9F%BA%E7%A1%80%E7%AF%87%2FJOIN%2F</url>
    <content type="text"><![CDATA[JOIN方法的使用 应用场景 阻塞当前线程，等待调用JOIN方法的线程执行结束后才继续执行。 因为新的线程加入了我们，所以我们要等他执行完再出发。 混淆点 JOIN方法是Thread类的方法，而notify()、notifyall()、wait()等方法是Object类的方法 主线程等待其他线程执行完的时候，主线程的状态是WAITING 方法的定义 不带参数的join方法表示必须等调用JOIN方法的线程执行结束后，才继续执行当前线程。 方法内部调用的是以毫秒为单位的JOIN方法。 123public final void join() throws InterruptedException &#123; join(0); &#125; 以毫秒为单位的JOIN方法。 内部实现调用了Object的wait方法。 参数表示如果等待millis毫秒后，你还没执行完成，我就继续往下执行了。 join可以让本线程等待别的线程执行完毕， Thread.join()调用相当于Thread.join(0) ，代码内的逻辑是，先判断如果输入的时间小于0就抛异常，然后就分为两种情况： 第一种是传入0的情况，这也是默认的情况，那么就代表永久等待，直到线程执行完毕，但是我们去看代码，看到了： while (isAlive()) { ​ wait(0); ​ } 但是哪里有唤醒的行为呢？我们前面讲过，wait(0)代表一直休眠，直到被notify()，那么为什么我们看不到notify()的相关代码，却依然能在线程运行结束后，自动被唤醒呢？ 秘密就在Thread类在run方法运行结束后，自动执行notifyAll()，让我们看看一看JVM层代码： 通过对Jvm natvie的源码分析,我们发现thread执行完成后，cpp的源码中会在thread执行完毕后,会调用exit方法,该方法中原来隐含有调用notify_all(thread)的动作: void JavaThread::exit(booldestroy_vm,ExitTypeexit_type)；//做清理、收尾工作， 上面的方法中会调用 ensure_join(this); 下面是ensure_join方法的源码: static void ensure_join(JavaThread*thread){ ​ Handle threadObj(thread,thread-&gt;threadObj()); ​ ObjectLocker lock(threadObj,thread);thread-&gt;clear_pending_exception(); ​ java_lang_Thread::set_thread_status(threadObj(),java_lang_Thread::TERMINATED); ​ java_lang_Thread::set_thread(threadObj(),NULL); ​ lock.notify_all(thread); //这里执行了notify_all,进行了wait的唤醒 ​ thread-&gt;clear_pending_exception(); } 通过以上分析后，我们就可以有了join的替代写法: ​ synchronized(thA) { ​ thA.wait(); ​ } 12345678910111213141516171819202122232425public final synchronized void join(long millis) throws InterruptedException &#123; long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) &#123; throw new IllegalArgumentException("timeout value is negative"); &#125; // 等待的时间为0，只有线程还是运行状态，则永远等待 // 这里使用了wait方法，那么在哪里notify/notify呢？ if (millis == 0) &#123; while (isAlive()) &#123; wait(0); &#125; &#125; else &#123; while (isAlive()) &#123; long delay = millis - now; if (delay &lt;= 0) &#123; break; &#125; wait(delay); now = System.currentTimeMillis() - base; &#125; &#125; &#125; 两个参数的JOIN方法，实现对纳秒级别的控制，很少使用。 当纳秒数大于500000，或者纳秒不为0，毫秒为0时，使毫秒数+1 123456789101112131415161718public final synchronized void join(long millis, int nanos)throws InterruptedException &#123; if (millis &lt; 0) &#123; throw new IllegalArgumentException("timeout value is negative"); &#125; if (nanos &lt; 0 || nanos &gt; 999999) &#123; throw new IllegalArgumentException( "nanosecond timeout value out of range"); &#125; if (nanos &gt;= 500000 || (nanos != 0 &amp;&amp; millis == 0)) &#123; millis++; &#125; join(millis);&#125; 注意点 1.如果同时调用多个join，join会有一定的顺序。 2.join是一个native方法 join方法中使用了wait方法，那么在哪里notify/notify呢？ 在每个线程的run方法结束后，会执行notify/notifyall方法 栗子1创建两个线程，每个线程休眠2s后，输出当前线程状态。 在main线程中调用join方法，等待两个线程执行完毕后继续执行main线程。 123456789101112131415161718192021222324252627282930313233343536373839404142public class JoinDemo01 &#123; public static void main(String[] args) &#123; Thread thread1 = new Thread(() -&gt; &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "run over! " + Thread.currentThread().getState()); &#125;); Thread thread2 = new Thread(() -&gt; &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "run over! " + Thread.currentThread().getState()); &#125;); thread1.start(); thread2.start(); System.out.println(Thread.currentThread() + "are waiting " + thread1.getName() + " and " + thread2.getName()); // 这里参数设置为1000，有特别意义 try &#123; System.out.println("join:" + new Date()); thread1.join(1000); System.out.println("join:" + new Date()); thread2.join(1000); System.out.println("join:" + new Date()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("final: " + thread1.getName() + thread1.getState()); System.out.println("final: " + thread2.getName() + thread2.getState()); &#125;&#125; 执行结果： 34s的时候调用thread1.join方法，在thread1线程的run方法是sleep2s，参数设置为等待1s后继续往下执行。 即当35s的时候调用thread2.join方法，在thread2线程的run方法是sleep2s，但是在34s的时候thread1,thread2都start了， 所以在36s的时候，thread1，thread2都已经执行完成了。 那么，就会有一个问题，main方法接下来的输出语句和thread1,thread2中run方法的输出语句，哪个先执行？ 这是不确定的，多次运行会发现结果不同，而结果的不同会体现在线程的状态不同 123456789// 线程先执行完后输出语句Thread[main,5,main]are waiting Thread-0 and Thread-1join:Wed Jun 24 23:59:34 CST 2020join:Wed Jun 24 23:59:35 CST 2020Thread-1run over! RUNNABLEThread-0run over! RUNNABLEjoin:Wed Jun 24 23:59:36 CST 2020final: Thread-0TERMINATEDfinal: Thread-1TERMINATED 123456// 先输出了语句，线程再执行完。好像会受输出时间的打印语句影响？？？Thread[main,5,main]are waiting Thread-0 and Thread-1final: Thread-0RUNNABLEfinal: Thread-1BLOCKED // 这里的BLOCKED是IO的阻塞，因为线程的BLOCKED状态只有在ysnchronized的时候才会出现Thread-0run over! RUNNABLEThread-1run over! RUNNABLE 栗子21234567891011121314151617181920212223242526272829303132333435363738394041public class JoinDemo02 &#123; public static void main(String[] args) &#123; Thread t1 = new Thread(() -&gt; &#123; try &#123; Thread.sleep(4000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + " run over!"); &#125;); Thread mainThread = Thread.currentThread(); Thread t2 = new Thread(() -&gt; &#123; //调用主线程的interrupt方法, 开启中断标记, 会影响主线中的join方法抛出异常,但是并不会阻碍t1线程的运行 mainThread.interrupt(); System.out.println(mainThread.getName() + " interrupt!"); System.out.println(Thread.currentThread().getName() + " run over!"); &#125;); t1.start(); t2.start(); System.out.println(Thread.currentThread().getName() + " wait " + t1.getName() + " and " + t2.getName() + " run over!"); try &#123; t1.join(); // 等待t1线程执行完毕，才继续往下执行 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("final:" + t1.getName() + " and " + t2.getName() + " run over!"); System.out.println("t1's state:" + t1.getState()); // TIME_WAITING System.out.println("t2's state:" + t2.getState()); // TERMINTED System.out.println("main's state:" + mainThread.getState()); // RUNNABLE， &#125;&#125; 执行结果： main方法运行后，thread2先运行，thread2中中断了main线程，影响了main线程的join方法，抛出异常，但不会影响thread1的执行。 从异常信息可以看到，中断main线程影响的是main线程中的join方法，thread1仍然正常执行，从thread1的线程状态是TIMED_WAITING可以看出。 12345678910111213main wait Thread-0 and Thread-1 run over!main interrupt!Thread-1 run over!java.lang.InterruptedException at java.lang.Object.wait(Native Method) at java.lang.Thread.join(Thread.java:1252) at java.lang.Thread.join(Thread.java:1326) at thread03.JoinDemo02.main(JoinDemo02.java:28)final:Thread-0 and Thread-1 run over!t1's state:TIMED_WAITINGt2's state:TERMINATEDmain's state:RUNNABLEThread-0 run over! 接着，我们修改一下线程2的方法： 123456Thread t2 = new Thread(() -&gt; &#123; //修改为t1.interrupt();观察效果, 会影响t1线程的sleep方法抛出异常,让t1线程结束 t1.interrupt(); System.out.println(t1.getName() + " interrupt!"); System.out.println(Thread.currentThread().getName() + " run over!");&#125;); 执行结果： 在thread2的方法中中断thread1的执行，这时中断的是thread1的sleep方法，thread1会抛出异常，继续往下执行，不再sleep了。 从异常信息可以看出是thread1的sleep方法被打断了，而且thread1的线程状态是TERMINATED。而main线程的状态是RUNNABLE，对主线程无影响。 123456789101112main wait Thread-0 and Thread-1 run over!Thread-0 interrupt!Thread-1 run over!java.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at thread03.JoinDemo02.lambda$main$0(JoinDemo02.java:18) at java.lang.Thread.run(Thread.java:748)Thread-0 run over!final:Thread-0 and Thread-1 run over!t1's state:TERMINATEDt2's state:TERMINATEDmain's state:RUNNABLE 总结： interrupt方法可以中断sleep()、join()等方法 某个线程如果被interrupt()打断，会抛出InterruptedException，并继续往下执行。可以在抛出异常后，再次调用子线程的interrupt方法，将中断信号传递给子线程。子线程处理中断信号后，就不会继续往下执行了]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[延时加载.md]]></title>
    <url>%2F2020%2F08%2F10%2FSpringBoot%2FBean%2F%E5%BB%B6%E6%97%B6%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[如何将一个类加入到Spring的IOC容器中呢？Spring为我们提供了5个注解： 1.@Component 2.@Controller 3.@Service 4.@Repository 5.@Configuration 其中，@Component是最基本的注解，其他的4个注解都是基于@Component. 在现在的Spring版本中，@Controller、@Service、@Repository的作用与@Component一致，以后Spring的更新可能会增强这几个注解。 @Configuration与其他几个注解不同的是它可以将多个类加入到IOC容器，而其他注解一次只能加入一个类到IOC容器中。 细节：如果一个类没有加入到IOC容器中，而另外一个类注入了这个类，在IDEA中会报错。当然，可以设置IDEA的报错级别。最好的办法是设置@Autowired(required = false)，这样这个类不是必须的，服务器可以正常启动。要注意的是，如果有地方调用了这个类的方法，会引起NullPointException. Spring中的对象实例化的时机？ 我们猜测，对象的实例化时机有以下两种情况： 1.当要使用到对象的时候进行实例化。比如Controller，是在访问了url的时候，IOC容器才实例化Controller 2.当IOC容器启动的时候实例化。比如服务器启动，所有的对象都会被实例化。 通过在类的构造方法中添加输出语句，在服务器启动的时候就输出了语句，可以知道第二种情况是Spring种默认的实例化Bean的方式。 延迟加载 那有什么办法可以延迟实例化Bean吗？这时候就得请出来大哥——@Lazy 我们举个栗子。在下面的类中添加@Lazy注解： 123456789101112@Component@Lazypublic class Diana&#123; public Diana()&#123; System.out.println("Diana start"); &#125; public void R()&#123; System.out.println("Diana R"); &#125;&#125; 在别的类中注入Diana这个类： 123456789101112131415@RestController@RequestMapping("/v1/banner")public class BannerController &#123; @Autowired private Diana diana; @GetMapping(value = "test") public Map&lt;String,Object&gt; test() &#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("id","1"); map.put("name","王小喵2"); return map; &#125;&#125; 此时，Diana就可以被延迟加载了吗？ 答案是否定的。在控制台的输出结果中，还是出现了Diana Start。也就是在IOC容器启动的时候，Diana就被实例化了。 咦，那是哪里出了问题呢？问题在于BannerController中注入了Diana。如果一个类想要延时加载，必须保证其他类没有使用到它。不然使用了该类的其他类也需要延时加载。说起来有点绕，意思就是说BannerController注入了Diana类，而Diana类想要延时加载，那么BannerController类也需要加上@Lazy注解进行延时加载。 加上注解后验证，Diana和BannerController都被延迟加载了。那么，它们在什么时候会被实例化呢？没错，在使用到它们的时候就会被实例化。我们在浏览器中访问BannerController对应的url，控制台输出Diana Start，它们被实例化了。推测✔ 注意：除非有特别好的理由，否则不推荐使用延时加载]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>延时加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[子线程异常处理.md]]></title>
    <url>%2F2020%2F08%2F10%2F%E5%B9%B6%E5%8F%91%2F%E5%9F%BA%E7%A1%80%E7%AF%87%2F%E5%AD%90%E7%BA%BF%E7%A8%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[栗子1：主线程无法捕获子线程抛出的异常12345678910111213141516171819202122public class UnCaughtException &#123; public static void main(String[] args) &#123; try &#123; MyThread myThread = new MyThread(); new Thread(myThread, "thread-1").start(); new Thread(myThread, "thread-2").start(); new Thread(myThread, "thread-3").start(); new Thread(myThread, "thread-4").start(); &#125; catch (RuntimeException e) &#123; System.out.println("主线程捕获了子线程抛出的异常"); &#125; &#125;&#125;class MyThread implements Runnable &#123; @Override public void run() &#123; throw new RuntimeException("我是来自子线程的异常"); &#125;&#125; 执行结果： 因为try..catch..只能捕获当前线程内抛出的异常。 123456789101112Exception in thread "thread-1" Exception in thread "thread-4" Exception in thread "thread-2" Exception in thread "thread-3" java.lang.RuntimeException: 我是来自子线程的异常 at threadexception.MyThread.run(UnCaughtException.java:34) at java.lang.Thread.run(Thread.java:748)java.lang.RuntimeException: 我是来自子线程的异常 at threadexception.MyThread.run(UnCaughtException.java:34) at java.lang.Thread.run(Thread.java:748)java.lang.RuntimeException: 我是来自子线程的异常 at threadexception.MyThread.run(UnCaughtException.java:34) at java.lang.Thread.run(Thread.java:748)java.lang.RuntimeException: 我是来自子线程的异常 at threadexception.MyThread.run(UnCaughtException.java:34) at java.lang.Thread.run(Thread.java:748) 栗子2：使用Thread类的UncaughtExceptionHandler接口实现全局捕获异常1234567// 自定义异常处理器，由于是函数式接口，可以使用Lambda表达式public class UnCaughtExceptionHandler implements Thread.UncaughtExceptionHandler &#123; @Override public void uncaughtException(Thread t, Throwable e) &#123; System.out.println(t.getName() + "发生了异常;" + e.getMessage()); &#125;&#125; 1234567891011121314151617181920public class UnCaughtException &#123; public static void main(String[] args) &#123; // 设置默认的异常处理器 Thread.setDefaultUncaughtExceptionHandler(new UnCaughtExceptionHandler()); MyThread myThread = new MyThread(); new Thread(myThread, "thread-1").start(); new Thread(myThread, "thread-2").start(); new Thread(myThread, "thread-3").start(); new Thread(myThread, "thread-4").start(); &#125;&#125;class MyThread implements Runnable &#123; @Override public void run() &#123; throw new RuntimeException("我是来自子线程的异常"); &#125;&#125; 执行结果： 1234thread-1发生了异常;我是来自子线程的异常thread-3发生了异常;我是来自子线程的异常thread-2发生了异常;我是来自子线程的异常thread-4发生了异常;我是来自子线程的异常 如何处理子线程出现的异常？ 在子线程内部try..catch..处理 设置Thread默认的异常处理器，全局处理异常]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发基础，异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建线程的方式.md]]></title>
    <url>%2F2020%2F08%2F10%2F%E5%B9%B6%E5%8F%91%2F%E5%9F%BA%E7%A1%80%E7%AF%87%2F%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[方式一：继承Thread类创建线程在举栗子之前，我们先定义一个Account实体类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Account &#123; private Integer accountId; // 账户id private String accountName; // 账户名称 private Boolean vaild; // 账户状态是否可用 public Account() &#123; &#125; public Account(Integer accountId, String accountName, Boolean vaild) &#123; this.accountId = accountId; this.accountName = accountName; this.vaild = vaild; &#125; @Override public String toString() &#123; return "Account&#123;" + "accountId=" + accountId + ", accountName='" + accountName + '\'' + ", vaild=" + vaild + '&#125;'; &#125; public Integer getAccountId() &#123; return accountId; &#125; public void setAccountId(Integer accountId) &#123; this.accountId = accountId; &#125; public String getAccountName() &#123; return accountName; &#125; public void setAccountName(String accountName) &#123; this.accountName = accountName; &#125; public Boolean getVaild() &#123; return vaild; &#125; public void setVaild(Boolean vaild) &#123; this.vaild = vaild; &#125;&#125; 使用继承Thread类的方法创建线程： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class CreateThreadByExtend extends Thread &#123; private Account account; public void setAccount(Account account) &#123; this.account = account; &#125; public CreateThreadByExtend() &#123; &#125; public CreateThreadByExtend(Account account) &#123; this.account = account; &#125; @Override public void run() &#123; System.out.println("正在执行run方法时，thread的状态:" + this.getName() + ":" + this.getState()); System.out.println("正在执行run方法时，account information:" + this.account); &#125; public static void main(String[] args) &#123; Account acc = new Account(1, "account1", true); CreateThreadByExtend thread1 = new CreateThreadByExtend(); thread1.setAccount(acc); System.out.println("thread对象已经创建，但是还没有start时，线程的状态:" + thread1.getName() + ":" + thread1.getState()); thread1.start(); // 确保线程已经执行完毕 try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("thread已经运行完毕后，线程的状态:" + thread1.getName() + ":" + thread1.getState()); System.out.println("thread执行完毕后，account information:" + acc); System.out.println("*************************"); Thread thread2 = new CreateThreadByExtend(acc); thread2.start(); &#125;&#125; 运行结果： 12345678thread对象已经创建，但是还没有start时，线程的状态:Thread-0:NEW正在执行run方法时，thread的状态:Thread-0:RUNNABLE正在执行run方法时，account information:Account&#123;accountId=1, accountName='account1', vaild=true&#125;thread已经运行完毕后，线程的状态:Thread-0:TERMINATEDthread执行完毕后，account information:Account&#123;accountId=1, accountName='account1', vaild=true&#125;*************************正在执行run方法时，thread的状态:Thread-1:RUNNABLE正在执行run方法时，account information:Account&#123;accountId=1, accountName='account1', vaild=true&#125; 需要注意以下几个问题： 1.变量可以通过什么方式传递给线程？ ​ 可以通过setter方法，或者带参构造函数。 2.线程的状态？ ​ 在new Thread，但未start之前，线程的状态是NEW。在start线程后，线程的状态是RUNNABLE。在线程运行完成后，线程的状态是TERMINATED。 3.使用继承Thread的方式创建线程有什么优点、缺点？ * 优点：可以使用Thread类已经有的方法，可以使用this去调用 * 缺点：Java的单继承机制使得只能继承Thread一个类 方式二：使用Runnable创建线程1234567891011121314151617181920212223242526272829303132333435363738394041424344public class CreateThreadByImplement implements Runnable &#123; private Account account; public CreateThreadByImplement() &#123; &#125; public CreateThreadByImplement(Account account) &#123; this.account = account; &#125; public void setAccount(Account account) &#123; this.account = account; &#125; @Override public void run() &#123; System.out.println("正在执行run方法时，thread的状态:" + Thread.currentThread() + ":" + Thread.currentThread().getState()); System.out.println("正在执行run方法时，account information:" + this.account); &#125; public static void main(String[] args) &#123; Account acc = new Account(1, "account1", true); CreateThreadByImplement runnable = new CreateThreadByImplement(); runnable.setAccount(acc); Thread thread1 = new Thread(runnable); System.out.println("thread对象已经创建，但是还没有start时，线程的状态:" + thread1.getName() + ":" + thread1.getState()); thread1.start(); // 确保线程已经执行完毕 try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("thread已经运行完毕后，线程的状态:" + thread1.getName() + ":" + thread1.getState()); System.out.println("thread执行完毕后，account information:" + acc); System.out.println("*************************"); Thread thread2 = new Thread(new CreateThreadByImplement(acc)); thread2.start(); &#125; 实现Runnable接口的类需要借助Thread类来启动线程，因为Runnable接口中没有start()方法。 不能使用this关键字了，需要使用Thread的静态方法来获取线程信息等。 使用Runnable接口实现可以继承其他类且可以继承多个接口，缺点是在run方法中不可以用this直接使用Thread的方法，需要使用Thread.currentThread先获取到线程对象 方式三：使用Callable创建线程1234567891011121314151617181920212223242526272829303132333435363738394041public class CreateThreadByCallable implements Callable&lt;Account&gt; &#123; private Account account; public CreateThreadByCallable() &#123; &#125; public CreateThreadByCallable(Account account) &#123; this.account = account; &#125; public void setAccount(Account account) &#123; this.account = account; &#125; @Override public Account call() &#123; System.out.println("正在执行run方法时，account information:" + this.account); this.account.setVaild(false); return account; &#125; public static void main(String[] args) &#123; Account acc = new Account(1, "account1", true); CreateThreadByCallable callable = new CreateThreadByCallable(acc); callable.setAccount(acc); FutureTask&lt;Account&gt; futureTask = new FutureTask&lt;Account&gt;(callable); Thread thread1 = new Thread(futureTask); thread1.start(); // 确保线程已经执行完毕 try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("在call方法中修改Account信息后，account information:" + acc); &#125;&#125; Callable接收一个泛型参数，这个参数影响call方法的返回值以及FutureTask的类型值。 使用Callable接口创建线程， 优点：线程可以有返回值 缺点：需要使用FutureTask封装一层，再传递给Thread 对比：执行run方法的本质我们来看一下继承Thread类的run方法是怎么实现的？ 123456789/* What will be run. */private Runnable target;@Overridepublic void run() &#123; if (target != null) &#123; target.run(); &#125;&#125; Thread类的run方法实际上是调用Runnable接口的run方法。但如果是继承Thread类来实现线程，那就重写了Thread类的run方法，启动线程实际上执行的是重写后的代码。 123456class MyThread extend Thread &#123; @Override public void run() &#123; // 自己编写的run方法，覆盖了Thread类原有的run方法 &#125;&#125; 验证1：到底执行谁的run方法？我们采用传入一个Runnable对象的方式创建一个线程。既实现Runnable接口的run方法，又重写Thread类的run方法，那么线程启动到底执行哪个run方法呢？ 1234567891011121314151617// 使用匿名内部类的方式创建Runnable对象，如果使用Lambda表达式，不能在Lambda表达式中重写run方法public class BothThreadAndRunnable &#123; public static void main(String[] args) &#123; Thread t = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("我是Runnable接口的run方法"); &#125; &#125;) &#123; @Override public void run() &#123; System.out.println("我是重写Thread类的run方法"); &#125; &#125;; t.start(); &#125;&#125; 执行结果： 1我是重写Thread类的run方法 从执行结果可知，我们重写的run方法覆盖了Thread类的run方法。也就是覆盖了Thread类的以下代码，使得Thread不再调用Runnable对象的run方法 12345678910111213@Overridepublic void run() &#123; System.out.println("我是重写Thread类的run方法");&#125;// 我们重写的run方法(⬆)覆盖了Thread类的run方法(⬇) @Overridepublic void run() &#123; if (target != null) &#123; target.run(); &#125;&#125; 面试1：一句话总结线程的创建方式准确地讲，创建线程只有一种方式，那就是构造Thread类。而实现线程的执行单元有两种方式： 实现Runnable接口的run方法，并把Runnable实例传递给Thread类 继承Thread类，重写Thread类的run方法 面试2：继承Thread类和实现Runnable接口的方法有什么优缺点？ 继承Thread类 优点： 可以直接使用this关键字调用Thread类当中的方法 缺点： Java中不支持多继承，缺少灵活性、扩展性 新建线程的损耗多，一个Thrad类就只能使用一次 实现Runnable接口 优点： 灵活性、扩展性好 新建线程的损耗小，实现了Runnable的对象可以被多个Thread反复使用 缺点： 不能使用this关键字，需要使用Thread的静态方法]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yield方法.md]]></title>
    <url>%2F2020%2F08%2F10%2F%E5%B9%B6%E5%8F%91%2F%E5%9F%BA%E7%A1%80%E7%AF%87%2FYield%2F</url>
    <content type="text"><![CDATA[yield方法的使用 Thread类中的静态native方法 让出剩余的时间片，本身进入就绪状态,不释放锁 cpu调度还可能调度到本线程 sleep是在一段时间内进入阻塞状态，cpu不会调度它。而yield是让出执行权，本身还处于就绪状态，cpu还可能立即调度它 yield方法的定义1public static native void yield(); 栗子11234567891011121314151617181920public class YieldDemo02 extends Thread &#123; public static Object lock = new Object(); @Override public void run() &#123; synchronized (lock) &#123; System.out.println(this.getName() + " yield"); // 打开关闭此注释查看输出效果，对比差异 this.yield(); System.out.println(this.getName() + " run over"); &#125; &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 1000; i++) &#123; YieldDemo02 demo = new YieldDemo02(); demo.start(); &#125; &#125;&#125; 执行结果： yield是有建议权的，一旦cpu采取了它的建议，就会让出时间片。 但是执行结果却是“间接”的，无论线程的数量有多少，执行结果都是间接有序的，这是为什么呢？ 因为有synchronized关键字，synchronized保证原子性。而另一方面，也说明了yield()方法只是让出剩余的时间片，但是不释放锁。 1234Thread-0 yieldThread-0 run overThread-4 yieldThread-4 run over await与yield的对比 wait也是让出执行权，它与yield的区别是，wait会释放锁 wait需要配合使用synchronized关键字和notifyAll()使用 12345678910111213141516171819202122232425262728293031public class YieldDemo02 extends Thread &#123; public static Object lock = new Object(); @Override public void run() &#123; synchronized (lock) &#123; System.out.println(this.getName() + " yield"); //使用wait方法来做对比，查看释放锁与不释放锁的区别 try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(this.getName() + " run over"); &#125; &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 1000; i++) &#123; YieldDemo02 demo = new YieldDemo02(); demo.start(); &#125; // 配合wait使用看效果 synchronized (lock) &#123; lock.notifyAll(); &#125; &#125;&#125; 执行结果： 输出结果是先输出yield，再输出run over。且先输出yield的后输出run over。 可以看出，虽然在synchronized代码块内，但是wait方法是释放锁的。 1234Thread-0 yieldThread-1 yieldThread-1 run overThread-0 run over 总结： yield方法最好不要使用，JDK也不推荐使用，但是保留这个方法的目的是在一些包中会有使用到，我们自己尽量不要去使用]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生产者与消费者.md]]></title>
    <url>%2F2020%2F08%2F10%2F%E5%B9%B6%E5%8F%91%2F%E5%9F%BA%E7%A1%80%E7%AF%87%2F%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[栗子1：使用wait/notify方法来实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class ProducerAndConsumerExample &#123; public static void main(String[] args) &#123; Container container = new Container(); new Thread(new Consumer(container)).start(); new Thread(new Producer(container)).start(); &#125;&#125;class Consumer implements Runnable &#123; private Container container; public Consumer(Container container) &#123; this.container = container; &#125; @Override public void run() &#123; try &#123; for (int i = 0; i &lt; 100; i++) &#123; container.take(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class Producer implements Runnable &#123; private Container container; public Producer(Container container) &#123; this.container = container; &#125; @Override public void run() &#123; try &#123; for (int i = 0; i &lt; 100; i++) &#123; container.put(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;// 实现类似于阻塞队列的容器class Container &#123; private Integer maxSize = 30; private LinkedList&lt;Integer&gt; queue; public Container() &#123; queue = new LinkedList&lt;&gt;(); &#125; public synchronized void put() throws InterruptedException &#123; // 队列已满，阻塞等待，使用while而不是使用if while (this.queue.size() == maxSize) &#123; this.wait(); &#125; this.queue.add(1); System.out.println("添加到容器,容器内还有" + this.queue.size() + "个数据"); // 通知消费者取数据 this.notifyAll(); &#125; public synchronized void take() throws InterruptedException &#123; // 队列为空，阻塞等待，使用while而不是使用if while (this.queue.size() == 0) &#123; this.wait(); &#125; this.queue.poll(); System.out.println("取出数据，容器内还有" + this.queue.size() + "个数据"); // 通知生产者生产数据 this.notifyAll(); &#125;&#125;]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[死锁.md]]></title>
    <url>%2F2020%2F08%2F10%2F%E5%B9%B6%E5%8F%91%2F%E5%9F%BA%E7%A1%80%E7%AF%87%2F%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[什么是死锁死锁就是两个（或更多）线程相互持有对方所需要的资源，又不主动释放资源，导致程序陷入无尽的阻塞，这就是死锁。 多个线程造成死锁的情况：等待的资源，形成一个环 死锁的影响 死锁的影响在不同的系统中是不一样的，这取决于系统对死锁的处理能力 数据库中：检测并放弃事务 JVM中：无法自行处理，但是JVM能检测出死锁 一个必然造成死锁的栗子 当类的对象flag=1时（T1），先锁定O1,睡眠500毫秒，然后锁定O2； 而T1在睡眠的时候另一个flag=0的对象（T2）线程启动，先锁定O2,睡眠500毫秒，等待T1释放O1； T1睡眠结束后需要锁定O2才能继续执行，而此时O2已被T2锁定； T2睡眠结束后需要锁定O1才能继续执行，而此时O1已被T1锁定； T1、T2相互等待，都需要对方锁定的资源才能继续执行，从而死锁。 同时注意一点，死锁的程序退出状态码是130. Process finished with exit code 130 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * @Author Ming * @Date 2020/07/22 22:07 * @Description 演示必然造成死锁的栗子，线程1先获取lock1锁，线程2先获取lock2锁 * 短暂休眠保证两个线程都获取了锁之后，之后争夺类锁会造成死锁 */public class MustHappenDeedLock implements Runnable &#123; // 控制不同的进程执行不同的代码块 private int flag; // 必须加static关键字，如果是对象锁，则不会造成死锁，因为使用不同的对象创建线程 private static Object lock1 = new Object(); private static Object lock2 = new Object(); public static void main(String[] args) &#123; // 创建两个线程争夺类锁 MustHappenDeedLock mustHappenDeedLock1 = new MustHappenDeedLock(); MustHappenDeedLock mustHappenDeedLock2 = new MustHappenDeedLock(); mustHappenDeedLock1.flag = 0; mustHappenDeedLock2.flag = 1; new Thread(mustHappenDeedLock1).start(); new Thread(mustHappenDeedLock2).start(); &#125; @Override public void run() &#123; if (flag == 0) &#123; synchronized (lock1) &#123; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lock2) &#123; System.out.println(Thread.currentThread().getName() + "获得了两把锁"); &#125; &#125; &#125; if (flag == 1) &#123; synchronized (lock2) &#123; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lock1) &#123; System.out.println(Thread.currentThread().getName() + "获得了两把锁"); &#125; &#125; &#125; &#125;&#125; 死锁的4个必要条件 互坼条件：在同一时刻，只能有一个线程拥有资源 请求与保持条件：自己不释放资源，又去申请别的资源 不剥夺条件：没有外界的干扰 循环等待条件：多个线程没有形成环路 死锁的形成，这4个条件缺一不可 如何定位死锁 jstack（jvm命令，可以先用jps lvm查看JVM进程） ThreadMXBean（代码） 修复死锁的策略 线上发生死锁应该怎么办 保存案发现场，然后立刻重启服务器 暂时保证线上服务的安全，然后再利用刚才保存的信息，排查死锁，修改代码，重新发布 1.避免策略 避免相反的获取锁的顺序* 通过hashcode来决定获取锁的顺序，冲突时需要“加时赛” * 实际工程中可以利用数据库的主键 哲学家就餐问题 2.检测与恢复策略 ​ 一段时间检测是否有死锁，如果有就剥夺某一个资源，来打开死锁 3.鸵鸟策略 ​ 如果发生死锁的概率非常低，我们就直接忽略它，直到死锁发生的时候，再人工修复。 栗子1：哲学家就餐问题（换序避免死锁）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * @Author Ming * @Date 2020/07/21 20:20 * @Description 哲学家就餐问题演示 */public class DiningPhilosopher &#123; public static void main(String[] args) &#123; // 创建哲学家 Philosopher[] philosophers = new Philosopher[5]; // 创建筷子 Object[] chopsticks = new Object[philosophers.length]; for (int i = 0; i &lt; chopsticks.length; i++) &#123; chopsticks[i] = new Object(); &#125; for (int i = 0; i &lt; philosophers.length; i++) &#123; Object leftChopstick = chopsticks[i]; Object rightChopstick = chopsticks[(i + 1) % chopsticks.length]; // 最后一位哲学家，先拿右边的筷子,避免死锁 if (i == philosophers.length - 1) &#123; philosophers[i] = new Philosopher(rightChopstick, leftChopstick); &#125; philosophers[i] = new Philosopher(leftChopstick, rightChopstick); new Thread(philosophers[i], "哲学家" + (i + 1)).start(); &#125; &#125; // 一个线程代表一个哲学家 public static class Philosopher implements Runnable &#123; // 锁对象代表筷子 private Object left = new Object(); private Object right = new Object(); public Philosopher(Object left, Object right) &#123; this.left = left; this.right = right; &#125; @Override public void run() &#123; while (true) &#123; doAction("thinking"); // 获取左边的筷子 synchronized (left) &#123; doAction("获取左边的筷子"); synchronized (right) &#123; doAction("获取右边的筷子- eating"); &#125; doAction("放下右边的筷子"); &#125; doAction("放下左边的筷子"); &#125; &#125; private void doAction(String action) &#123; System.out.println(Thread.currentThread().getName() + ":" + action); try &#123; Thread.sleep(ThreadLocalRandom.current().nextInt(1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 另：哲学界就餐问题解决的4种方案： 服务员检查（避免策略） 改变一个哲学界拿叉子的顺序，换序（避免策略） 餐票，只有拿到餐票的才能就餐，就餐完返回餐票（避免策略） 领导调节（检测与恢复策略） 栗子2：银行转账（hashCode换序避免死锁）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** * @Author Ming * @Date 2020/07/22 22:28 * @Description 银行转账的栗子，演示死锁的发生，以及通过换序避免死锁的产生 */public class TransferMoneyDeedLock implements Runnable &#123; private static Account account1 = new Account(500); private static Account account2 = new Account(500); private int flag; private static Object lock = new Object(); public static void main(String[] args) throws InterruptedException &#123; TransferMoneyDeedLock transferMoneyDeedLock1 = new TransferMoneyDeedLock(); TransferMoneyDeedLock transferMoneyDeedLock2 = new TransferMoneyDeedLock(); transferMoneyDeedLock1.flag = 0; transferMoneyDeedLock2.flag = 1; Thread thread1 = new Thread(transferMoneyDeedLock1, "account1"); Thread thread2 = new Thread(transferMoneyDeedLock2, "account2"); thread1.start(); thread2.start(); thread1.join(); thread2.join(); System.out.println("account1 balance:" + account1.balance); System.out.println("account2 balance:" + account2.balance); &#125; @Override public void run() &#123; if (flag == 0) &#123; transferMoney(account1, account2, 200); &#125; if (flag == 1) &#123; transferMoney(account2, account1, 200); &#125; &#125; public static void transferMoney(Account from, Account to, Integer amount) &#123; // 获取对象的hashcode来决定获取锁的顺序 int fromHashCode = System.identityHashCode(from); int toHashCode = System.identityHashCode(to); if (fromHashCode &gt; toHashCode) &#123; synchronized (from) &#123; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (to) &#123; transferHelper(from, to, amount); &#125; &#125; &#125; else if (fromHashCode &lt; toHashCode) &#123; synchronized (to) &#123; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (from) &#123; transferHelper(from, to, amount); &#125; &#125; &#125; else &#123; // hash冲突的情况，额外加一把锁，公平竞争执行的机会 synchronized (lock) &#123; // 先对from加锁还是to加锁已经不重要了,有了外层的lock,from和to不会同时被获取 synchronized (to) &#123; synchronized (from) &#123; transferHelper(from, to, amount); &#125; &#125; &#125; &#125; &#125; public static void transferHelper(Account from, Account to, Integer amount) &#123; if (from.balance - amount &gt; 0) &#123; from.balance -= amount; to.balance += amount; System.out.println(Thread.currentThread().getName() + "转账" + amount); &#125; else &#123; System.out.println("转账失败"); &#125; &#125; static class Account &#123; private Integer balance; public Account(Integer balance) &#123; this.balance = balance; &#125; &#125;&#125; 实际工程中如何避免死锁 设置超时时间 多使用并发类而不是自己设计锁 尽量降低锁的使用粒度：用不同的锁而不是一个锁 如果能使用同步代码块，就不使用同步方法：自己指定锁对象 给线程起个有意义的名字：debug和排查时事半功倍 避免锁的嵌套 分配资源前先看能不能收回来：银行家算法 尽量不要几个功能用同一把锁：专锁专用 什么是活锁虽然线程并没有阻塞，也始终在运行，但是程序却得不到进展，因为线程始终重复做同样的事 栗子2：牛郎织女没饭吃（加入随机因素解决活锁）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * @Author Ming * @Date 2020/07/21 21:47 * @Description 演示活锁，牛郎和织女互相谦让勺子，最后谁都吃不上饭 */public class LiveLock &#123; public static void main(String[] args) &#123; Diner boy = new Diner("牛郎"); Diner girl = new Diner("织女"); // 牛郎先拥有勺子 Spoon spoon = new Spoon(boy); new Thread(() -&gt; boy.eatWith(spoon, girl)).start(); new Thread(() -&gt; girl.eatWith(spoon, boy)).start(); &#125; static class Spoon &#123; private Diner owner; public Spoon(Diner owner) &#123; this.owner = owner; &#125; public synchronized void use() &#123; System.out.println(owner.name + "正在使用勺子"); &#125; &#125; static class Diner &#123; private String name; private boolean isHunger; public Diner(String name) &#123; this.name = name; isHunger = true; &#125; public void eatWith(Spoon spoon, Diner partner) &#123; while (this.isHunger) &#123; // 先判断勺子在不在自己手上 if (this != spoon.owner) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; continue; &#125; // 判断女朋友饿不饿 // 加入随机因素解决活锁 int random = ThreadLocalRandom.current().nextInt(10); if (partner.isHunger &amp;&amp; random &lt; 9) &#123; System.out.println(this.name + ":亲爱的，你先吃吧"); spoon.owner = partner; continue; &#125; // 勺子在自己手上 spoon.use(); this.isHunger = false; System.out.println(this.name + "吃完了"); spoon.owner = partner; &#125; &#125; &#125;&#125; 什么是饥饿当线程需要某些资源（例如CPU），但是却始终得不到 线程的优先级设置得过于低，或者有某线程持有锁同时又无限循环从而不释放锁，或者某程序始终占用某文件的写锁 饥饿可能会导致响应性差：比如，我们的浏览器有一个线程负责处理前台响应（打开收藏夹等动作），另外的后台线程负责下载图片和文件、计算渲染等。在这种情况下，如果后台线程把CPU资源都占用了，那么前台线程将无法得到很好地执行，这会导致用户的体验很差]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程安全.md]]></title>
    <url>%2F2020%2F08%2F10%2F%E5%B9%B6%E5%8F%91%2F%E5%9F%BA%E7%A1%80%E7%AF%87%2F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0%2F</url>
    <content type="text"><![CDATA[从JVM的内存模型上看，线程安全的问题是由于多个线程争夺共享内存的同一共享资源而产生的。 多个线程争夺共享内存的同一共享资源就一定会产生线程安全问题吗？ 不一定，如果多条线程不修改共享资源，那么不会产生线程安全问题。 线程安全产生的两个原因 可见性 多个线程访问同一个共享变量时，其中一个线程对这个共享变量值的修改，其他线程能够立刻获得修改以后的值。 原子性 和数据库事务中的原子性一样，满足原子性特性的操作是不可中断的，要么全部执行成功要么全部执行失败 例子1User类是一个实体类，提供了set方法修改密码。 UserServlet中提供了setPass的方法修改密码。 12345678910111213141516171819202122232425262728293031323334class User &#123; private String name; private String password; public User(String name, String password) &#123; this.name = name; this.password = password; &#125; public String getName() &#123; return name; &#125; public String getPassword() &#123; return password; &#125; public void set(String name, String password) &#123; this.name = name; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; this.password = password; System.out.println(Thread.currentThread() + ":" + this.name + ":" + this.password); &#125;&#125;class UserServlet &#123; public void setPass(User user) &#123; user.set(user.getName(), user.getPassword()); &#125;&#125; 创建两个线程访问UserServlet： 12345public static void main(String[] args) &#123; UserServlet userServlet = new UserServlet(); new Thread(() -&gt; userServlet.setPass(new User("李四", "777777"))).start(); new Thread(() -&gt; userServlet.setPass(new User("王五", "888888"))).start(); &#125; 这里的共享资源是什么？ 误区1： 被抢占的资源是User 实际上，User对象是在每个线程的独立工作内存中创建的。它并不是共享资源。 这里的共享资源是UserServlet对象。两个线程共享着主内存区域创建的UserServlet对象。当每个线程调用setPass方法的时候，争夺UserServlet对象的使用权来修改自己独有内存区域的User对象的name和password。 这里是线程安全的吗？ 线程安全！虽然两个线程共享着同一个UserServlet对象，但是线程只是调用UserServlet里的setPass方法来修改线程自己内存区域的对象，而不是对共享资源的修改，所以不存在线程安全的问题。 而且UserServlet不存在全局变量或静态变量被修改。 new出来的对象不是存放在堆中吗？而堆是共享内存，为什么不存在线程安全问题？ JVM的内存模型中，方法区和堆是共享内存区，而虚拟机栈、本地方法栈、程序技术器是每个线程独有的。 虽然new出来的对象保存在堆中，但是对象的引用保存在线程独有的虚拟机栈中。并不会被别的线程修改，所以不存在线程安全的问题。 运行结果 不管运行多少次，结果都一样。 12Thread[Thread-0,5,main]:李四:777777Thread[Thread-1,5,main]:王五:888888 总结 多条线程抢占共享区的对象使用权，调用对象的方法，并不会引起线程安全的问题。 例子1修改这个例子与上面的不同的地方在于UserServlet中有一个默认User对象。提供给外部一个根据name和password修改默认User对象的方法。 1234567891011121314151617181920212223242526272829303132333435363738394041class User &#123; private String name; private String password; public User(String name, String password) &#123; this.name = name; this.password = password; &#125; public String getName() &#123; return name; &#125; public String getPassword() &#123; return password; &#125; public void set(String name, String password) &#123; this.name = name; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; this.password = password; System.out.println(Thread.currentThread() + ":" + this.name + ":" + this.password); &#125;&#125;class UserServlet &#123; private User user; public UserServlet() &#123; user = new User("张三", "11111"); &#125; public void setPass(String name, String password) &#123; user.set(name, password); &#125;&#125; 12345public static void main(String[] args) &#123; UserServlet userServlet = new UserServlet(); new Thread(() -&gt; userServlet.setPass("李四", "777777")).start(); new Thread(() -&gt; userServlet.setPass("王五", "888888")).start(); &#125; 这里的共享资源是什么？ ​ 这里的共享资源是UserServlet对象。更具体地说，两个线程共享着UserServlet对象中的User对象。 这里存在线程安全吗？ ​ 存在！两个线程共享一个User对象。当线程对User对象进行修改时，就会出现线程安全的问题。 运行结果 12Thread[Thread-0,5,main]:王五:777777Thread[Thread-1,5,main]:王五:888888 ​ 结果分析： ​ 当线程1修改User对象的name后，线程1Sleep 5s，线程二开始修改User对象，此时，线程2会将线程1之前修改name=李四 覆盖为 name=王五，接着线程2Sleep 5s，线程1醒来，修改password=777777。线程2醒来，修改password=888888 为什么password不会被线程2覆盖为888888 因为线程1Sleep 5s后才会将password保存到主内存区的User对象上。而不是在修改name的时候就把password一起保存到主内存区。 如果去掉SetPass方法中的Thread,Sleep()方法，执行结果是怎样的？ 12Thread[Thread-0,5,main]:李四:777777Thread[Thread-1,5,main]:王五:888888 如果去掉Thread,sleep方法，执行结果是正确的。事实上，正是因为线程1的Sleep方法，为了不浪费cpu，使得线程2有机会抢占执行。如果没有线程1的Sleep方法，线程2只能等线程1执行完成后才有机会执行。（不一定，看时间片分配？？？） ​ 总结 多条线程抢占共享区域的对象，修改对象的成员变量，会引起线程安全的问题。 执行结果错误的本质原因 ​ 线程的执行不是原子性的。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程与线程.md]]></title>
    <url>%2F2020%2F08%2F10%2F%E5%B9%B6%E5%8F%91%2F%E5%9F%BA%E7%A1%80%E7%AF%87%2F%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[操作系统、进程、线程的关系 操作系统将资源分配给进程，进程将资源分配给线程。但是CPU资源比较特殊，CPU资源是直接分配给线程的。 一个进程中至少会有一个线程，进程不能脱离进程而存在。 main函数启动的时候，会产生JVM进程，JVM进程会产生多条线程。main函数线程称为主线程。还有产生GC回收的守护线程。 JVM内存模型与线程的关系虽然对象是存在Java堆中的，但是对象的引用存放在虚拟机栈中。 使用JDK工具观察线程注意，如果没有将对应的命令加入到环境变量中，需要到JDK所在路径的bin目录下执行。 在观察的时候，可以让main线程Sleep(Integer.MAX_VALUE)，目的是为了让JVM进程不停止，这样才能观察到线程。 jps -lvm 可以看到系统中运行的进程。在使用jcmd的时候，需要带上进程的id。 jcmd jstack 可视化工具 jvisualvm 有动态图查看线程的运行状态 可视化工具 jconsole 可以查看Thread等类的属性等信息，可以单独对某个线程查看，可以检测死锁 线程的状态 线程的性能问题上下文切换可以认为是内核（操作系统的核心）在 CPU 上对于进程（包括线程）进行以下的活动：（1）挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处，（2）在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复，（3）跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程。 缓存开销:CPU重新缓存 何时会导致密集的上下文切换:频繁地竞争锁，或者由于IO读写等原因导致频繁阻塞 ​ 协作：内存同步 ​ 为了数据的正确性，同步手段往往会使用禁止编译器优化、使CPU内的缓存失效]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程的启动与终止.md]]></title>
    <url>%2F2020%2F08%2F10%2F%E5%B9%B6%E5%8F%91%2F%E5%9F%BA%E7%A1%80%E7%AF%87%2F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E4%B8%8E%E5%81%9C%E6%AD%A2%2F</url>
    <content type="text"><![CDATA[start方法源码 对线程状态进行检查，0代表NEW状态 将线程加入线程组 调用native方法start0() 12345678910111213141516171819202122232425public synchronized void start() &#123; // A zero status value corresponds to state "NEW". if (threadStatus != 0) throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group's list of threads * and the group's unstarted count can be decremented. */ group.add(this); boolean started = false; try &#123; // native方法 start0(); started = true; &#125; finally &#123; try &#123; if (!started) &#123; group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; &#125; &#125; &#125; 面试题1：一个线程两次调用start方法会出现什么情况？为什么？​ 会抛出IllegalThreadStateException。因为调用start方法时会对线程状态进行检查，不是NEW状态就会抛出IllegalThreadStateException。 面试题2：为什么选择调用start方法，而不直接调用run方法？​ 调用start方法才是真正的启动线程，会有线程的生命周期。而直接调用run方法，只是调用了一个普通方法。 如何正确停止线程：使用interrupt来通知，而不是强制​ 只是使用interrupt来通知线程，通过设置线程中断标志来实现，线程根据这个标志来自行处理。 interupted的三种情况 线程正常执行完成，调用interrpted方法 线程可能被阻塞 线程在每次迭代后都阻塞 栗子1：线程正常执行，需要线程自行根据中断标志来处理interrupt方法的通知1234567891011121314151617181920212223242526272829303132333435public class InterruptDemo01 &#123; public static void main(String[] args) &#123; Thread thread1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 999999; i++) &#123; // 必须自行处理中断，只是调用interrupt方法是无效的 if (Thread.currentThread().isInterrupted()) &#123; System.out.println(Thread.currentThread().getName() + " interrupted"); break; &#125; System.out.println(Thread.currentThread().getName() + i + " is running"); &#125; &#125;); thread1.start(); // 运行1s后再中断程序 try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; thread1.interrupt(); // 等待thread1执行完才输出thread1的线程状态 try &#123; thread1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("thread1 status:" + thread1.getState()); &#125;&#125; 执行结果： 12345......Thread-0139724 is runningThread-0139725 is runningThread-0 interruptedthread1 status:TERMINATED 栗子2：线程处在阻塞状态时，interrupt方法结束线程，抛出异常将以上栗子1中的Thread方法改成以下： 12345678910Thread thread1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 999999; i++) &#123; System.out.println(Thread.currentThread().getName() + i + " is running"); &#125; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;); 执行方法： thread处在sleep状态时，被中断抛出异常。 1234567Thread-0999997 is runningThread-0999998 is runningjava.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at threadcore.InterruptedDemo01.lambda$main$0(InterruptedDemo01.java:24) at java.lang.Thread.run(Thread.java:748)thread1 status:TERMINATED 栗子3：线程在迭代中处于阻塞状态，interrupt方法结束线程，抛出异常将栗子1中的Thread方法修改为以下： 12345678910Thread thread1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 999999; i++) &#123; System.out.println(Thread.currentThread().getName() + i + " is running"); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;); 执行结果： 线程被中断后，抛出异常，catch捕获异常后，线程继续执行。 12345678Thread-00 is runningjava.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at threadcore.InterruptedDemo01.run(InterruptedDemo01.java:48) at java.lang.Thread.run(Thread.java:748)Thread-01 is runningThread-02 is running...... 栗子4：捕获异常的位置会影响执行结果在栗子3的基础上，将捕获异常的代码块范围增大。 12345678910Thread thread1 = new Thread(() -&gt; &#123; try &#123; for (int i = 0; i &lt; 999999; i++) &#123; System.out.println(Thread.currentThread().getName() + i + " is running"); Thread.sleep(100); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;); 执行结果： 线程接收到中断通知后，会抛出异常。处理异常后，不再执行循环了，而是执行完线程接下来的任务就结束了。异常的捕获范围影响了线程的执行。 1234567891011Thread-00 is runningThread-01 is runningThread-02 is runningThread-03 is runningThread-04 is runningjava.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at threadcore.InterruptedDemo01.run(InterruptedDemo01.java:49) at java.lang.Thread.run(Thread.java:748)抛出异常后我还会继续执行thread1 status:TERMINATED 栗子5：在迭代中try..catcha异常会导致interrupt方法失效在栗子3中，我们在迭代中使用了try..catch..捕获了异常，线程继续往下执行。 那么，是不是加上isInterrupted方法的判断，捕获异常后，线程就不往下执行了呢？ 1234567891011Thread thread1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 999999 &amp;&amp; !Thread.currentThread().isInterrupted(); i++) &#123; System.out.println(Thread.currentThread().getName() + i + " is running"); try &#123; // sleep会清除中断标志，导致isInterrupted()方法无法判断 Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;); 执行结果： 线程在捕获了异常后，还是继续往下执行了。 12345678......Thread-04 is runningjava.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at threadcore.InterruptedDemo01.run(InterruptedDemo01.java:48) at java.lang.Thread.run(Thread.java:748)Thread-05 is running...... interrupt()与interrupted()区别interrupted方法，不管是谁调用，都只对当前线程有效 123456789101112131415161718192021222324252627282930public class InterruptDemo02 &#123; public static void main(String[] args) &#123; Thread t1 = new Thread(() -&gt; &#123; // 3.条件为!true=false,退出循环 // isInterrupted()返回中断标志true while (!Thread.currentThread().isInterrupted()) &#123; &#125; //4.这里输出的是什么true还是false System.out.println(Thread.currentThread().getName() + ":" + Thread.currentThread().isInterrupted()); &#125;); //1.开启 t1.start(); //2.中断标记设置为true t1.interrupt(); try &#123; t1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("main is run over"); &#125;&#125; 执行结果： t1.interrupt()设置了中断标志=true，isInterrupted()返回中断标志true，不会清除中断标志 12Thread-0:truemain is run over 如果改成interrupted()方法呢？ 1234567Thread t1 = new Thread(() -&gt; &#123; while (!Thread.interrupted()) &#123; &#125; //4.这里输出的是什么true还是false System.out.println(Thread.currentThread().getName() + ":" + Thread.currentThread().isInterrupted());&#125;); 执行结果： t1.interrupt()设置了中断标志=true，Thread.interrupted()返回中断标志=true,并且清除了中断标志=false 下面的输出语句输出中断标志=false 12Thread-0:falsemain is run over interrupt方法源码intertupt方法只是设置线程中断标志。 123456789101112131415public void interrupt() &#123; // interrupt方法只对当前线程有效，谁调用了interrupt方法，就中断谁 if (this != Thread.currentThread()) checkAccess(); synchronized (blockerLock) &#123; Interruptible b = blocker; if (b != null) &#123; interrupt0(); // Just to set the interrupt flag b.interrupt(this); return; &#125; &#125; interrupt0();&#125; 相关方法： 123456789101112// 不清楚中断标志public boolean isInterrupted() &#123; return isInterrupted(false);&#125;// 清除当前线程的中断标志public static boolean interrupted() &#123; return currentThread().isInterrupted(true);&#125;// native方法，参数代表是否清除中断标志private native boolean isInterrupted(boolean ClearInterrupted); 中断线程的两种姿势 不在线程方法内部try..catch，把异常抛出去，由调用方处理中断异常 在线程方法内部try..catch，并在catch后，再次中断线程，恢复中断，这样方法调用方能处理中断 响应线程中断的N种方法 Object ：wait Thread：sleep，join BlockQueue：take/put Lock：lockInterruptibly CountDownLatch：await CyclicBarrier：await Exchanger：exchange java.nio.channels.InterruptibleChannel相关方法 java.nio.channels.Selector的相关方法 错误的停止线程的方法 stop/suspend/resume 用volatile设置的boolean标记位，在阻塞的时候，线程不会响应标记位的更新 栗子1：生产者与消费者模式证明在阻塞的时候，使用volatile设置的标记位来停止线程是错误的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class ProducerAndConsumer &#123; public static void main(String[] args) &#123; ArrayBlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;Integer&gt;(10); Producer producer = new Producer(queue); Thread thread = new Thread(producer); thread.start(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Consumer consumer = new Consumer(queue); while (consumer.needMoreNums()) &#123; try &#123; Object num = queue.take(); System.out.println(num + "被消费了"); Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("消费者不需要数据了"); producer.cancel = true; // 线程被阻塞，而不会停止 // thread.interrupt(); // 正确的停止方式 &#125;&#125;class Consumer &#123; private BlockingQueue queue; public Consumer(BlockingQueue queue) &#123; this.queue = queue; &#125; public boolean needMoreNums() &#123; if (Math.random() &gt; 0.95) &#123; return false; &#125; return true; &#125;&#125;class Producer implements Runnable &#123; private BlockingQueue queue; public volatile boolean cancel = false; public Producer(BlockingQueue queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; int num = 0; try &#123; // 当消费者不需要数据的时候，生产者阻塞在put这一行代码，导致while的判断条件种cancel无法检测 while (num &lt; 10000 &amp;&amp; !cancel) &#123; if (num % 100 == 0) &#123; queue.put(num); System.out.println(num + "被生产出来放入队列了"); &#125; num++; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[synchronized.md]]></title>
    <url>%2F2020%2F08%2F10%2F%E5%B9%B6%E5%8F%91%2F%E5%9F%BA%E7%A1%80%E7%AF%87%2F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8ESynchronized%2F</url>
    <content type="text"><![CDATA[什么是线程安全 当多个线程访问某一个类、对象或方法时，这个类、对象或方法都能表现出与单线程执行时一致的行为，那么这个类、对象或方法就是线程安全的 线程安全问题都是由全局变量（成员变量）以及静态变量引起的 若每个线程中对全局变量、静态变量只有读操作，没有写操作，一般来说，这个全局变量是线程安全的。若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就有可能影响线程安全 需要考虑线程安全的情况 访问共享的变量或资源，会有并发风险，比如对象的属性、静态变量、共享缓存、数据库等 check-then-act操作：一个线程读取了一个共享数据，并在此基础上决定其下一个的操作 不同的数据之间存在捆绑关系的时候 我们使用其他类的时候，如果对方没有声明自己是线程安全的，那么大概率会存在并发问题 栗子1：多个线程a++导致的线程安全问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class SumError implements Runnable &#123; private static SumError instance = new SumError(); private int sum = 0; // 记录1-10000有哪一次是计算出错的，默认值为false private boolean[] marked = new boolean[20001]; // 记录真正执行的次数 private AtomicInteger execNums = new AtomicInteger(); // 记录出错的次数 private AtomicInteger wrongNums = new AtomicInteger(); private CyclicBarrier cyclicBarrier1 = new CyclicBarrier(2); private CyclicBarrier cyclicBarrier2 = new CyclicBarrier(2); @Override public void run() &#123; // 考虑第一次就发生错误的情况 marked[0] = true; for (int index = 0; index &lt; 10000; index++) &#123; try &#123; /* 防止线程1执行完了，线程2还未执行检测， 又执行线程1的情况，又被cpu切换sum++了一次，这样会影响线程2漏检测 */ cyclicBarrier2.reset(); cyclicBarrier1.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; sum++; try &#123; /* 防止线程1在执行设置为true时，线程2把sum++了一次， 导致线程1检测的位置不对 */ cyclicBarrier1.reset(); cyclicBarrier2.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; try &#123; // 防止线程1还未检测，线程2把sum++了一次 cyclicBarrier2.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; // 执行次数增加 execNums.incrementAndGet(); /* 检测当前要累加的值是否已经被累加过了，如果是的话，就是计算出错了 synchronized保证检测的步骤和检测完设置为true的步骤是原子性的 有可能出现sum++了，第二个线程也sum++，原本我要判断的sum位置就错位了,所以需要CycleBarrier */ synchronized (instance) &#123; if (marked[sum] &amp;&amp; marked[sum - 1]) &#123; System.out.println("发生了错误:" + sum); // 发生错误的次数增加 wrongNums.incrementAndGet(); &#125; // 操作过后，设置true marked[sum] = true; &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Thread thread1 = new Thread(instance); thread1.start(); Thread thread2 = new Thread(instance); thread2.start(); thread1.join(); thread2.join(); System.out.println("最终的结果是:" + instance.sum); System.out.println("执行的次数是:" + instance.execNums); System.out.println("出现错误的次数是:" + instance.wrongNums); &#125;&#125; synchronized作用 synchronized的作用是加锁，所有的synchronieed方法都会顺序执行（这里指占用cpu的顺序） synchronized保证在同一时刻最多只有一个线程执行该段代码 synchronized能保证可见性和原子性，线程在执行结束前会把独立内存的值刷新回主内存，从而保证可见性 synchronized的执行方式 首先尝试获得锁 如果获得锁，则执行synchronized的方法体内容 如果无法获得锁，则等待并且不断尝试去获得锁，一旦锁被释放，则多个线程会同时去尝试获得锁，造成锁竞争的问题 synchronized的缺陷 效率低 锁竞争问题，在高并发、线程数量高时会引起CPU占用居高不下，或者直接宕机 锁的释放情况少，只有正常结束或抛出异常的时候才释放锁 试图获得锁时不能设定超时时间 不能中断一个正在试图获得锁的线程 不够灵活（读写锁更灵活） 加锁和释放的时机单一，每个锁仅有单一的条件（某个对象），可能是不够的 无法知道是否成功获取到锁 synchronized的两个用法：对象锁和类锁 对象锁：一个对象一个锁，多个对象之间不会发生锁竞争 方法锁，默认锁对象为this当前实例对象 同步代码块锁，自己指定任意对象(指定锁对象为this，相当于方法锁) 12345public synchronized void method()&#123;&#125;// 等价public void method()&#123; synchronized(this)&#123;&#125;&#125; 类锁：所有对象共享一把锁，存在锁竞争 synchronized加在静态方法 同步代码块指定锁为Class对象 栗子1：synchronized保证线程安全创建3个线程共享一个ThreadDemo01对象，并对对象中的成员变量进行了写操作。肯定会引发线程安全问题。 12345678910111213141516171819202122public class ThreadDemo01 implements Runnable &#123; private int count = 0; @Override public void run() &#123; count++; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "&gt;count=" + count); &#125; public static void main(String[] args) &#123; ThreadDemo01 threadDemo01 = new ThreadDemo01(); for (int i = 0; i &lt; 3; i++) &#123; new Thread(threadDemo01, "t" + i).start(); &#125; &#125;&#125; 输出结果： 存在线程安全问题！三条线程使用同一个threadDemo01创建线程。对threadDemo01对象中的count变量进行写的操作。 123t0&gt;count=3t1&gt;count=3t2&gt;count=3 使用synchronized方法加对象锁，解决线程安全问题：12345678910@Overridepublic synchronized void run() &#123; count++; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "&gt;count=" + count);&#125; 输出结果： 每隔2s中输出一次结果，不存在线程安全问题！ 当t0执行run方法时，对threadDemo01对象加对象锁，当t1执行run方法时，必须等待t0释放锁才能执行。 所以sleep2s后，t0执行完，t1就可以执行了。 123t0&gt;count=1t2&gt;count=2t1&gt;count=3 使用同步代码块方法加对象锁，解决线程安全问题123456789101112@Override public void run() &#123; synchronized (this) &#123; count++; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "&gt;count=" + count); &#125; &#125; 使用同步代码块指定锁为Class对象加类锁，解决线程安全问题123456789101112@Override public void run() &#123; synchronized (ThreadDemo01.class) &#123; count++; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "&gt;count=" + count); &#125; &#125; 使用static变量加类锁，解决线程安全问题12345678910111213141516private static int count = 0; @Override public void run() &#123; add(); &#125; public synchronized static void add() &#123; count++; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "&gt;count=" + count); &#125; 栗子2：对象锁和类锁12345678910111213141516171819202122232425public class ThreadDemo03 &#123; private int count = 0; //如果是static变量会怎样? public synchronized void add() &#123; count++; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "&gt;count=" + count); &#125; public static void main(String[] args) &#123; final ThreadDemo03 thread1 = new ThreadDemo03(); final ThreadDemo03 thread2 = new ThreadDemo03(); Thread t1 = new Thread(() -&gt; thread1.add()); Thread t2 = new Thread(() -&gt; thread1.add()); t1.start(); t2.start(); &#125;&#125; 执行结果： 同一个对象同一把锁 12Thread-0&gt;count=1Thread-1&gt;count=2 把main方法修改一下： 12345678public static void main(String[] args) &#123; final ThreadDemo03 thread1 = new ThreadDemo03(); final ThreadDemo03 thread2 = new ThreadDemo03(); Thread t1 = new Thread(() -&gt; thread1.add()); Thread t2 = new Thread(() -&gt; thread2.add()); t1.start(); t2.start();&#125; 执行结果： 不同对象，不同的锁 12Thread-0&gt;count=1Thread-1&gt;count=1 如果把count变量升级为静态变量： 1234567891011121314151617181920212223public class ThreadDemo03 &#123; private static int count = 0; //如果是static变量会怎样? public synchronized static void add() &#123; count++; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "&gt;count=" + count); &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(() -&gt; ThreadDemo03.add()); Thread t2 = new Thread(() -&gt; ThreadDemo03.add()); t1.start(); t2.start(); &#125;&#125; 执行结果： 对象锁升级为类锁，存在锁竞争问题 12Thread-0&gt;count=1Thread-1&gt;count=2 对象锁的同步与异步同步：必须等待方法执行完毕，才能向下执行，共享资源访问的时候，为了保证线程安全，必须同步 异步：不用等待其他方法执行完毕，即可以立即执行，例如Ajax异步 对象锁只针对synchronized修饰的方法生效、对象中的所有synchronized方法都会同步执行、而非 synchronized方法异步执行 避免误区：类中有两个synchronized方法，两个线程分别调用两个方法，相互之间也需要竞争锁， 因为两个方法从属于一个对象，而我们是在对象上加锁 栗子1：同步与异步执行123456789101112131415161718192021222324252627public class ThreadDemo02 &#123; //同步执行 public synchronized void print1() &#123; System.out.println("print1执行,时间:" + new Date()); System.out.println(Thread.currentThread().getName() + "&gt;hello!"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //异步执行 public void print2() &#123; System.out.println("print2执行,时间:" + new Date()); System.out.println(Thread.currentThread().getName() + "&gt;hello!"); &#125; public static void main(String[] args) &#123; ThreadDemo02 thread = new ThreadDemo02(); Thread t1 = new Thread(() -&gt; thread.print1(), "thread1"); Thread t2 = new Thread(() -&gt; thread.print2(), "thread1"); t1.start(); t2.start(); &#125;&#125; 执行结果： 两个线程共享一个ThreadDemo02对象，当t1执行synchronized void print1()时会加对象锁，而此时t2执行public void print2()能不能执行成功？是不是要等待t1释放锁才能执行？ 从运行结果来看，在同一时间，t1执行了print1方法，t2执行了print2方法，说明t2不需要等待t1释放锁。这时因为对象中的所有synchronized方法都会同步执行、而非 synchronized方法异步执行 1234print2执行,时间:Thu Jun 25 18:26:43 CST 2020print1执行,时间:Thu Jun 25 18:26:43 CST 2020thread1&gt;hello!thread1&gt;hello! 如果给print2也加上synchronized关键字： 1234public synchronized void print2() &#123; System.out.println("print2执行,时间:" + new Date()); System.out.println(Thread.currentThread().getName() + "&gt;hello!");&#125; 执行结果： 同一个对象的多个synchronized方法是同步执行的，多条线程如果调用的是synchronized方法，是要等待其他线程对该对象释放锁后才能执行的。 t1对print1加对象锁，t2要像访问同一对象的print2方法，就需要等待t1执行完毕释放锁才能继续执行，可以看到输出结果中sleep3s等待t1释放锁，才执行print2方法 1234print1执行,时间:Thu Jun 25 18:34:06 CST 2020thread1&gt;hello!print1执行,时间:Thu Jun 25 18:34:09 CST 2020thread1&gt;hello! 脏读由于同步和异步方法的执行个性，如果不从全局上进行并发设计很可能会引起数据的不一致，也就是所谓的脏读。 多个线程访问同一资源，在一个线程修改数据的过程中，有另外的线程来读取数据，就会引起脏读数据的产生。 为了避免脏读，我们一定要保证数据修改操作的原子性，并且对读操作也要进行同步控制 栗子1：脏读的产生线程修改ThreadDemo04的name和address属性，但是address还未修改成功，就被读取，从而发生了脏读。 123456789101112131415161718192021222324252627282930public class ThreadDemo04 &#123; private String name = "张三"; private String address = "大兴"; public synchronized void setVal(String name, String address) &#123; this.name = name; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; this.address = address; System.out.println("setValue最终结果：username = " + name + " , address = " + address); &#125; public void getVal() &#123; System.out.println("getValue方法得到：username = " + this.name + " , address = " + this.address); &#125; public static void main(String[] args) throws Exception &#123; final ThreadDemo04 dr = new ThreadDemo04(); Thread t1 = new Thread(() -&gt; dr.setVal("李四", "昌平")); t1.start(); // 睡眠1s,t1线程肯定还未执行结束 Thread.sleep(1000); dr.getVal(); &#125;&#125; 执行结果： 线程还未将地址修改，main线程将旧的数据读取了出来。 12getValue方法得到：username = 李四 , address = 大兴setValue最终结果：username = 李四 , address = 昌平 要解决脏读问题，对读操作也要进行同步控制： 123public synchronized void getVal() &#123; System.out.println("getValue方法得到：username = " + this.name + " , address = " + this.address); &#125; 执行结果： 12setValue最终结果：username = 李四 , address = 昌平getValue方法得到：username = 李四 , address = 昌平 synchronized的性质 不可中断性 一旦这个锁已经被别人获得了，如果我还想获得，我只能选择等待或者阻塞，直到别的线程释放这个锁。如果别人永远不释放锁，那么我只能永远地等下去。 可重入性 同一个线程得到了一个对象的锁之后，再次请求此对象时可以再次获得该对象的锁。（同一线程的外层函数获得锁之后，内层函数可以直接再次获取该锁） 1.优点：避免死锁，提升封装性 2.粒度： 证明同一个方法是可重入的（递归调用本方法） 证明可重入不要求是同一个方法（同一个对象内的多个synchromized方法可以锁重入） 证明可重入不要求是同一个类中的（父子类可以锁重入） 栗子1：同一个对象内的多个synchronized方法1234567891011121314151617public class ThreadDemo05 &#123; public synchronized void run1()&#123; System.out.println(Thread.currentThread().getName()+"&gt;run1..."); //调用同类中的synchronized方法不会引起死锁 run2(); &#125; public synchronized void run2()&#123; System.out.println(Thread.currentThread().getName()+"&gt;run2..."); &#125; public static void main(String[] args) &#123; final ThreadDemo05 threadDemo05 = new ThreadDemo05(); Thread thread = new Thread(() -&gt; threadDemo05.run1()); thread.start(); &#125;&#125; 执行结果： 线程首先调用了run1()方法，对threadDemo05对象加对象锁，在run1()方法中又调用了synchronized修饰的run2()方法，按理说，run1()方法还没有执行完毕，没有释放锁，执行run2()方法没有获得锁，是会发生死锁的。但是运行结果说明，同个对象的synchronized方法是可以锁重入的。 12Thread-0&gt;run1...Thread-0&gt;run2... 栗子2 ：父子类的锁重入在child类中synchronized方法中调用了Parent类的synchronized方法。 123456789101112131415161718192021222324252627282930class Parent &#123; public int i = 10; public synchronized void runParent() &#123; i--; System.out.println("Parent&gt;&gt;&gt;&gt;i=" + i); &#125;&#125;class Child extends Parent &#123; public synchronized void runChild() &#123; while (i &gt; 0) &#123; i--; System.out.println("Child&gt;&gt;&gt;&gt;i=" + i); //调用父类中的synchronized方法不会引起死锁 this.runParent(); &#125; &#125;&#125;public class ThreadDemo06 &#123; public static void main(String[] args) &#123; Thread t1 = new Thread(() -&gt; &#123; Child sub = new Child(); sub.runChild(); &#125;); t1.start(); &#125;&#125; 执行结果： Child类继承了Parent的i变量和runParent()。 当线程调用Child类的runChild()时，对sub对象加对象锁，而在runChild方法中又调用了runParent方法，按理说，runChild方法没有执行完毕，不会释放锁，runParent方法执行又需要获得锁，会发生死锁现象。从运行结果来看，父子类之间的多个synchronized方法是可以锁重入的。 12345678910Child&gt;&gt;&gt;&gt;i=9Parent&gt;&gt;&gt;&gt;i=8Child&gt;&gt;&gt;&gt;i=7Parent&gt;&gt;&gt;&gt;i=6Child&gt;&gt;&gt;&gt;i=5Parent&gt;&gt;&gt;&gt;i=4Child&gt;&gt;&gt;&gt;i=3Parent&gt;&gt;&gt;&gt;i=2Child&gt;&gt;&gt;&gt;i=1Parent&gt;&gt;&gt;&gt;i=0 抛出异常释放锁一个线程在获得锁之后执行操作，发生错误抛出异常，则自动释放锁。 可以利用抛出异常，主动释放锁 程序异常时防止资源被死锁，无法释放 异常释放锁可能导致数据不一致 栗子1：主动抛出异常，释放锁在变量i加到10的时候主动释放锁，才能让get方法获取变量i的值 123456789101112131415161718192021222324252627282930313233public class ThreadDemo07 &#123; private int i = 0; public synchronized void add() &#123; while (true) &#123; i++; System.out.println(Thread.currentThread().getName() + "-run&gt;i=" + i); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (i == 10) &#123; throw new RuntimeException(); &#125; &#125; &#125; // 防止脏读 public synchronized void get() &#123; System.out.println(Thread.currentThread().getName() + "-get&gt;i=" + i); &#125; public static void main(String[] args) throws InterruptedException &#123; final ThreadDemo07 threadDemo07 = new ThreadDemo07(); new Thread(() -&gt; threadDemo07.add(), "t1").start(); // 保证t1线程先执行 Thread.sleep(1000); new Thread(() -&gt; threadDemo07.get(), "t2").start(); &#125;&#125; 执行结果： 线程调用add方法，在add方法中对i进行累加，本会一直无限循环进行累加，但在add方法中主动抛出了异常，释放锁，而get方法就可以运行得到i的值。 这里需要注意的是，即使add方法没有释放锁，get方法也可以锁重入。但因为synchronized方法是同步执行的，所以get方法必须等add方法执行完才能执行。 ==所以这里要区分死锁问题和同步执行问题== 123456789101112131415t1-run&gt;i=1t1-run&gt;i=2t1-run&gt;i=3t1-run&gt;i=4t1-run&gt;i=5t1-run&gt;i=6t1-run&gt;i=7t1-run&gt;i=8t1-run&gt;i=9t1-run&gt;i=10t2-get&gt;i=10Exception in thread "t1" java.lang.RuntimeException at thread04.ThreadDemo07.run(ThreadDemo07.java:29) at thread04.ThreadDemo07.lambda$main$0(ThreadDemo07.java:41) at java.lang.Thread.run(Thread.java:748) synchronized代码块可以达到更细粒度的控制 当前对象锁 类锁 任意对象锁 栗子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class ThreadDemo08 &#123; public void run1() &#123; synchronized (this) &#123; try &#123; System.out.println(Thread.currentThread().getName() + "&gt;当前对象锁.."); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public void run2() &#123; synchronized (ThreadDemo08.class) &#123; try &#123; System.out.println(Thread.currentThread().getName() + "&gt;类锁.."); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private Object objectLock = new Object(); public void run3() &#123; synchronized (objectLock) &#123; try &#123; System.out.println(Thread.currentThread().getName() + "&gt;任意对象锁.."); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //测试方法 public static void test(final int type) &#123; if (type == 1) &#123; System.out.println("当前对象锁测试..."); &#125; else if (type == 2) &#123; System.out.println("类锁测试..."); &#125; else &#123; System.out.println("任意对象锁测试..."); &#125; final ThreadDemo08 demo1 = new ThreadDemo08(); final ThreadDemo08 demo2 = new ThreadDemo08(); Thread t1 = new Thread(() -&gt; &#123; if (type == 1) &#123; demo1.run1(); &#125; else if (type == 2) &#123; demo1.run2(); &#125; else &#123; demo1.run3(); &#125; &#125;, "t1"); Thread t2 = new Thread(() -&gt; &#123; if (type == 1) &#123; demo1.run1(); &#125; else if (type == 2) &#123; demo2.run2(); &#125; else &#123; demo1.run3(); &#125; &#125;, "t2"); t1.start(); t2.start(); &#125; public static void main(String[] args) &#123; test(1); // 测试当前对象锁 //test(2); // 测试类锁 //test(3); // 测试任意对象锁 &#125;&#125; 运行结果：test(1) 可以用同步代码块对当前对象加锁。 123当前对象锁测试...t1&gt;当前对象锁..t2&gt;当前对象锁.. test(2)： 可以用同步代码块对类加锁。 123类锁测试...t1&gt;类锁..t2&gt;类锁.. test(3): 可以用同步代码块对任意对象加锁。 123任意对象锁测试...t1&gt;任意对象锁..t2&gt;任意对象锁.. 我们测试一下当类锁和对象锁同时存在的情况： 12345678910111213 public static void main(String[] args) &#123; final ThreadDemo08 demo1 = new ThreadDemo08(); final ThreadDemo08 demo2 = new ThreadDemo08(); System.out.println(new Date()); // 加类锁 Thread t1 = new Thread(() -&gt; demo1.run2(), "t1"); t1.start(); // 加对象锁 Thread t2 = new Thread(() -&gt; demo2.run1(), "t2"); t2.start(); System.out.println(new Date());&#125; 执行结果： 从运行结果可以看到，在同一时间，两条线程并行执行了。并没有sleep2s，也就是说对象锁并不需要等待类锁释放才执行。 1234Thu Jun 25 22:19:14 CST 2020t1&gt;类锁..Thu Jun 25 22:19:14 CST 2020t2&gt;当前对象锁.. 总结：同类型锁之间互坼，不同类型的锁之间互不干扰 synchronized使用的几种情况 两个线程同时访问同一对象的synchronized方法 同一时刻只有一个线程访问，另一个线程阻塞，对象锁 两个线程同时访问不同对象的synchronized方法 两个线程并行执行，互不影响 两个线程访问的是synchronized的static方法 同一时刻只有一个线程访问，另一个线程阻塞，类锁 同时访问synchronized修饰的方法与没有sychronized修饰的方法 synchronized修饰的方法同步执行，没有synchronized修饰的方法异步执行 访问同一个对象实例的不同的非static的synchronized方法 同步执行，因为synchronized修饰的非static方法默认使用synchronized(this)加对象锁的方式 同时访问静态synchronized方法与非静态的synchronized方法 不会影响。同种类型的锁会互坼，不同类型的锁互不干扰。因为静态synchronized方法对class加锁，非静态synchronized方法对this加锁，不是同一把锁 方法抛出异常，释放锁 总结(3个核心思想)： 一把锁只能同时被一个线程获取，没有拿到锁的线程必须等待（对应1、5的情况） 每个实例都对应自己的一把锁，不同实例之间互不影响。例外：锁对象是*.class以及synchronized修饰的是static方法的时候，所有对象共用同一把类锁（对应2、3、4、6的情况） 无论是方法正常执行完毕或者方法抛出异常，都会释放锁（对应第7种情况） synchronized原理 加锁和释放锁的原理 1234567891011121314151617public synchronized void method() &#123;&#125;// synchronized加锁的机制类似如下代码Lock lock = new ReentrantLock();public void method() &#123; lock.lock(); // 情况1：抛出异常释放锁的情况 try &#123; &#125; finally &#123; lock.unlock(); &#125; // 情况2：正常结束释放锁的情况 lock.unlock();&#125; 反编译查看monitor javap -verbose SynchronizedLock.class 查看反编译文件。 一个monitorenter可以对应多个monitorexit，是因为进入之后度与退出的情况并不是一一对应的，多种退出方式使得exit数量可能大于enter的数量。 monitorenter使monitor计数器+1，monitorexit使计数器-1,如果变成没有变成0，说明之前是重入的，那么线程继续持有锁 12345678910111213141516Code: stack=2, locals=3, args_size=1 0: aload_0 1: getfield #3 // Field obj:Ljava/lang/Object; 4: dup 5: astore_1 6: monitorenter // 重点 7: aload_1 8: monitorexit // 重点 9: goto 17 12: astore_2 13: aload_1 14: monitorexit // 可能存在一个monitorenter对应着多个monitorexit,因为存在两种退出情况 15: aload_2 16: athrow 17: return 锁失效问题 不要在线程中修改对象锁的引用，引用被改变会导致锁失效。 在线程中修改了锁对象的属性，而不修改引用则不会引起锁失效，不会产生线程安全问题 栗子1：修改对象的引用会引起锁失效123456789101112131415161718192021222324public class ThreadDemo09 &#123; private String lock = "lock handler"; private void method() &#123; synchronized (lock) &#123; try &#123; System.out.println("当前线程 : " + Thread.currentThread().getName() + "开始"); Thread.sleep(2000); System.out.println("当前线程 : " + Thread.currentThread().getName() + "结束"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; final ThreadDemo09 changeLock = new ThreadDemo09(); Thread t1 = new Thread(() -&gt; changeLock.method(), "t1"); Thread t2 = new Thread(() -&gt; changeLock.method(), "t2"); t1.start(); t2.start(); &#125;&#125; 执行结果： 正常的执行结果： 1234当前线程 : t1开始当前线程 : t1结束当前线程 : t2开始当前线程 : t2结束 由于锁的引用被改变，所以t2线程也进入到method方法内执行。 12345678910111213private void method() &#123; synchronized (lock) &#123; try &#123; System.out.println("当前线程 : " + Thread.currentThread().getName() + "开始"); //锁的引用被改变,则其他线程可获得锁，导致并发问题 lock = "change lock handler"; Thread.sleep(2000); System.out.println("当前线程 : " + Thread.currentThread().getName() + "结束"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 执行结果： 从运行结果来看，synchronized同步代码块不能保证原子性了，同步失效了。这是因为在线程执行过程中，线程A修改了锁的引用，则线程B实际上得到了新的对象锁，而不是锁被释放了，因此引发了线程安全问题。 1234当前线程 : t1开始当前线程 : t1结束当前线程 : t2开始当前线程 : t2结束 栗子2：修改对象属性不会引起锁失效123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Person &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "DemoThread10 [name=" + name + ", age=" + age + "]"; &#125;&#125;public class ThreadDemo10 &#123; private Person person = new Person(); public void changeUser(String name, int age) &#123; synchronized (person) &#123; System.out.println("线程" + Thread.currentThread().getName() + "开始" + person); // 修改对象的属性，不会引起锁失效 person.setAge(age); person.setName(name); System.out.println("线程" + Thread.currentThread().getName() + "修改为" + person); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("线程" + Thread.currentThread().getName() + "结束" + person); &#125; &#125; public static void main(String[] args) &#123; final ThreadDemo10 thread10 = new ThreadDemo10(); new Thread(() -&gt; thread10.changeUser("小白", 99), "t1").start(); new Thread(() -&gt; thread10.changeUser("小黑", 100), "t2").start(); &#125;&#125; 执行结果： synchronized加的对象锁没有失效，没有出现线程安全问题。 123456线程t1开始DemoThread10 [name=null, age=0]线程t1修改为DemoThread10 [name=小白, age=99]线程t1结束DemoThread10 [name=小白, age=99]线程t2开始DemoThread10 [name=小白, age=99]线程t2修改为DemoThread10 [name=小黑, age=100]线程t2结束DemoThread10 [name=小黑, age=100] 一句话总结SynchronizedJVM会自动通过使用monitor来加锁和解锁，保证了同一时刻只有一个线程可以执行指定代码，从而保证了线程安全，同时具有可重入和不可中断的性质。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CyclicBarrier.md]]></title>
    <url>%2F2020%2F08%2F10%2F%E5%B9%B6%E5%8F%91%2F%E7%B2%BE%E9%80%9A%E7%AF%87%2FCyclicBarrier%2F</url>
    <content type="text"><![CDATA[简单介绍CyclicBarrier就像起跑线，规定了有多少个跑道(等待的线程数)，必须等所有的选手到位(最后一个线程执行完)之后，才可以开始跑。 CyclicBarrier初始值的设置需要与使用的数量相同，否则将会一直等待下去 CyclicBarrier可以设置最大等待时间，超出最大等待时间抛出TimeoutException并且先运行，运行之后会破坏Barrier，抛出BrokenBarrierException。当其他线程运行时，都会抛出BrokenBarrierException]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Semaphore.md]]></title>
    <url>%2F2020%2F08%2F10%2F%E5%B9%B6%E5%8F%91%2F%E7%B2%BE%E9%80%9A%E7%AF%87%2FSemaphore%2F</url>
    <content type="text"><![CDATA[使用信号量的注意点 获取和释放的数量保持一致 注意在初始化Semaphore的时候设置公平性，一般设置为true会更合理 并不是必须由获取许可证的线程释放那个许可证，]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程间通信.md]]></title>
    <url>%2F2020%2F08%2F10%2F%E5%B9%B6%E5%8F%91%2F%E5%9F%BA%E7%A1%80%E7%AF%87%2F%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[线程之间通讯每个线程都是独立运行的个体，线程通讯能让多个线程之间协同工作。 Object类中的wait/notify方法可以实现线程间通讯 wait/notify必须与synchronized一起使用，因为使用这些方法之前必须获得monitor锁 wait释放锁，且只释放当前对象锁，若有多个对象，不会影响到其他对象的锁 notify不释放锁 wait方法被唤醒的四种情况 另一个线程调用这个wait方法加锁对象的notify方法且刚好被唤醒的是本线程 另一个线程调用这个wait方法加锁对象的notifyAll方法 过了wait(long timeout)规定的超时时间，如果传入0就是永久等待 线程自身调用了interrupt() 栗子1：while方式实现线程间通讯启动一个线程调用put方法往全局变量list中添加元素，当添加了5个元素后，通知另一个线程调用get方法获取list中元素并输出 1234567891011121314151617181920212223242526272829303132333435363738394041public class ThreadDemo17 &#123; private volatile List&lt;String&gt; list = new ArrayList&lt;String&gt;(); private volatile boolean canGet = false; public void put() &#123; for (int i = 1; i &lt;= 10; i++) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; list.add("A"); System.out.println("线程" + Thread.currentThread().getName() + "添加第" + i + "个元素"); if (i == 5) &#123; //循环到第次则通知其他线程开始获取数据进行处理 canGet = true; System.out.println("线程" + Thread.currentThread().getName() + "发出通知"); &#125; &#125; &#125; public void get() &#123; while (true) &#123; if (canGet) &#123; for (String s : list) &#123; System.out.println("线程" + Thread.currentThread().getName() + "获取元素:" + s); &#125; break; &#125; &#125; &#125; public static void main(String[] args) &#123; ThreadDemo17 demo = new ThreadDemo17(); // 先添加元素 new Thread(() -&gt; demo.put(), "t1").start(); // 后获取元素 new Thread(() -&gt; demo.get(), "t2").start(); &#125;&#125; 执行结果： 12345678910111213141516线程t1添加第1个元素线程t1添加第2个元素线程t1添加第3个元素线程t1添加第4个元素线程t1添加第5个元素线程t1发出通知线程t2获取元素:A线程t2获取元素:A线程t2获取元素:A线程t2获取元素:A线程t2获取元素:A线程t1添加第6个元素线程t1添加第7个元素线程t1添加第8个元素线程t1添加第9个元素线程t1添加第10个元素 疑问： 1.一个线程修改全局变量，另外一个线程获取变量，不是会产生脏读吗？为什么没有加synchronized保证同步执行？ ​ 因为有全局变量canGet的控制，只有通过线程1改变了canGet的值，线程2才能get，并不会引起脏读。 这里需要对canGet变量加上volatile关键字，保证可见性。在个数为5的时候，线程t1已经更新了canGet=true,但是还未更新到主内存中，则线程t2取到的值不是最新的值。 2.当线程1，线程2运行结束后，list的size是多少？ ​ 10，当线程1添加到5个元素后，通知线程2，线程2获取元素并输出，然后就break退出循环了。但是线程1还在继续添加元素，直到线程1的循环10都结束。所以，最后list的size肯定是10，只不过线程2只是输出了前5个元素，就退出循环，不再输出了。 栗子2：wait/notify实现线程间通讯启动一个线程调用put方法往全局变量list中添加元素，当添加了5个元素后，通知另一个线程调用get方法获取list中元素并输出。先调用get方法，先保证get方法运行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class ThreadDemo18 &#123; //原子类 private volatile List&lt;String&gt; list = new ArrayList&lt;String&gt;(); private Object lock = new Object(); public void put() &#123; synchronized (lock) &#123; for (int i = 1; i &lt;= 10; i++) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; list.add("A"); System.out.println("线程" + Thread.currentThread().getName() + "添加第" + i + "个元素"); if (list.size() == 5) &#123; //数据准备好了,发出唤醒通知,但是不释放锁 lock.notify(); System.out.println("发出通知..."); &#125; &#125; &#125; &#125; public void get() &#123; synchronized (lock) &#123; try &#123; System.out.println("线程" + Thread.currentThread().getName() + "业务处理,发现有需要的数据没准备好,则发起等待"); System.out.println("线程" + Thread.currentThread().getName() + "wait"); lock.wait(); //wait操作释放锁,否则其他线程只能等该方法执行完后才能进入put方法 System.out.println("线程" + Thread.currentThread().getName() + "被唤醒"); for (String s : list) &#123; System.out.println("线程" + Thread.currentThread().getName() + "获取元素:" + s); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; ThreadDemo18 demo = new ThreadDemo18(); // 先调用get方法 new Thread(() -&gt; demo.get(), "t1").start(); // 保证get方法先被调用 try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 再调用put方法 new Thread(() -&gt; demo.put(), "t2").start(); &#125;&#125; 运行结果： 线程t1先启动，获取lock锁，进入get方法执行。执行到lock.wait时，释放锁，等待通知。 t1释放锁，线程t2获得锁，进入put方法执行，添加5个元素后，发出通知，但是notify不释放锁，会继续执行完t1后才释放锁。 当t1添加完10个元素，t1执行完成，释放锁。线程t2接着执行wait后的输出语句，输出list中的10个元素。 123456789101112131415161718192021222324线程t1业务处理,发现有需要的数据没准备好,则发起等待线程t1wait线程t2添加第1个元素线程t2添加第2个元素线程t2添加第3个元素线程t2添加第4个元素线程t2添加第5个元素发出通知...线程t2添加第6个元素线程t2添加第7个元素线程t2添加第8个元素线程t2添加第9个元素线程t2添加第10个元素线程t1被唤醒线程t1获取元素:A线程t1获取元素:A线程t1获取元素:A线程t1获取元素:A线程t1获取元素:A线程t1获取元素:A线程t1获取元素:A线程t1获取元素:A线程t1获取元素:A线程t1获取元素:A notify唤醒 notify方法只应该被拥有该对象的monitor的线程调用 要等刚才执行notify的线程退出被synchronized保护的代码并释放monitor notify与notifyAll的区别notifyAll 使所有原来在该对象上等待被notify的线程统统退出wait的状态，变成等待该对象上的锁，一旦该对象被解锁，他们就会去竞争。 notify 只是选择一个wait状态线程进行通知，并使它获得该对象上的锁，但不惊动其他同样在等待被该对象notify的线程们，当第一个线程运行完毕以后释放对象上的锁此时如果该对象没有再次使用notify语句，则即便该对象已经空闲，其他wait状态等待的线程由于没有得到该对象的通知，继续处在wait状态，直到这个对象发出一个notify或notifyAll，它们等待的是被notify或notifyAll，而不是锁。 栗子1：只调用一次notify12345678910111213141516171819202122232425262728293031323334353637public class ThreadDemo19 &#123; public synchronized void run1() &#123; System.out.println("进入run1方法.."); this.notify(); System.out.println("run1执行完毕,通知完毕.."); &#125; public synchronized void run2() &#123; try &#123; System.out.println("进入run2方法.."); this.wait(); System.out.println("run2执行完毕.."); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public synchronized void run3() &#123; try &#123; System.out.println("进入run3方法.."); this.wait(); System.out.println("run3执行完毕.."); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; ThreadDemo19 demo = new ThreadDemo19(); // 先执行等待通知的线程 new Thread(() -&gt; demo.run2()).start(); new Thread(() -&gt; demo.run3()).start(); Thread.sleep(1000L); // 再执行发送通知的线程 new Thread(() -&gt; demo.run1()).start(); &#125;&#125; 执行结果： run2,run3方法先运行，等待通知。sleep1s后，run1方法运行，使用notify发送通知，只会发送一个通知。 run2收到通知，执行完毕。run3没有收到通知，还在等待着notify/notifyAll才可以继续运行。 12345进入run2方法..进入run3方法..进入run1方法..run1执行完毕,通知完毕..run2执行完毕.. 如果run2方法修改成如下： 1234567891011public synchronized void run2() &#123; try &#123; System.out.println("进入run2方法.."); this.wait(); System.out.println("run2执行完毕.."); this.notify(); System.out.println("run2发出通知.."); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; 执行结果： 在run2方法中再次发送了notify通知，此时只有run3一个方法在等待通知，自然就是run3接收到通知，执行完毕。可以看到，notify类似于链式操作。 1234567进入run2方法..进入run3方法..进入run1方法..run1执行完毕,通知完毕..run2执行完毕..run2发出通知..run3执行完毕.. 栗子2：使用notifyAll12345678910111213141516171819202122232425262728293031323334353637public class ThreadDemo19 &#123; public synchronized void run1() &#123; System.out.println("进入run1方法.."); this.notifyAll(); System.out.println("run1执行完毕,通知完毕.."); &#125; public synchronized void run2() &#123; try &#123; System.out.println("进入run2方法.."); this.wait(); System.out.println("run2执行完毕.."); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public synchronized void run3() &#123; try &#123; System.out.println("进入run3方法.."); this.wait(); System.out.println("run3执行完毕.."); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; ThreadDemo19 demo = new ThreadDemo19(); // 先执行等待通知的线程 new Thread(() -&gt; demo.run2()).start(); new Thread(() -&gt; demo.run3()).start(); Thread.sleep(1000L); // 再执行发送通知的线程 new Thread(() -&gt; demo.run1()).start(); &#125;&#125; 执行结果： 使用notifyAll通知，所有的等待通知的线程都会收到通知。 123456进入run2方法..进入run3方法..进入run1方法..run1执行完毕,通知完毕..run3执行完毕..run2执行完毕.. 守护进程与用户进程 main函数所在线程是一个用户线程 只要有一个用户线程还没结束，jvm进程就不会结束 父线程结束后，子线程还可以继续存活，子线程的生命周期不受父线程影响 线程上下文切换当前线程使用完时间片后就会进入就绪状态，让出cpu执行权给其他线程，此时就是从当前线程的上下文切换到了其他线程。 当发生上下文切换的时候需要保存执行现场，待下次执行时进行恢复。 所以频繁的，大量的上下文切换会造成一定资源开销。 sleep方法 Thread类中的一个静态方法 暂时让出执行权，不参与CPU调度，但是不释放锁，包括synchronized和lock sleep之后，本身进入阻塞状态，时间到了就进入就绪状态，一旦获取到CPU时间片，则继续执行 清除中断状态 一句话总结：Sleep方法可以让线程进入TIME_WAITING状态，并且不占用CPU资源，但是不释放锁，直到规定时间后再执行，休眠期间如果被中断，会抛出异常且清除中断标志 栗子1：两个线程交替打印1-100，使用wait/notify12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 两个线程执行自己的for循环，用判断是否奇偶的方式来控制打印顺序public class OddExample &#123; public static void main(String[] args) &#123; Object lock = new Object(); Thread thread1 = new Thread(() -&gt; &#123; synchronized (lock) &#123; for (int i = 0; i &lt; 100; i++) &#123; if (i % 2 == 0) &#123; System.out.println(Thread.currentThread().getName() + ":偶数------:" + i); try &#123; // 输出了偶数之后等待唤醒 lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; else &#123; lock.notify(); &#125; &#125; &#125; &#125;); Thread thread2 = new Thread(() -&gt; &#123; synchronized (lock) &#123; for (int i = 0; i &lt; 100; i++) &#123; if (i % 2 != 0) &#123; System.out.println(Thread.currentThread().getName() + ":奇数:" + i); try &#123; // 输出奇数后等待被唤醒 lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; else &#123; lock.notify(); &#125; &#125; &#125; &#125;); thread1.start(); thread2.start(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435// 共享变量i,控制好i初始值,直接打印，打印完唤醒其他线程打印，不需要判断是否奇偶public class OddExample4 &#123; public static void main(String[] args) &#123; PrintThread printThread = new PrintThread(); new Thread(printThread).start(); new Thread(printThread).start(); &#125;&#125;class PrintThread implements Runnable &#123; private int i = 0; private Object lock = new Object(); @Override public void run() &#123; // 直接打印，打印完换醒其他线程，自己休眠，不需要再判断是否奇偶 while (i &lt;= 100) &#123; synchronized (lock) &#123; System.out.println(Thread.currentThread().getName() + ":" + i); i++; lock.notify(); // 一定要判断是小于100的才阻塞等待，否则当i&gt;100的时候，没有线程notify了，会导致线程一直被阻塞 if (i &lt;= 100) &#123; try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;&#125; 栗子2：两个线程交替打印1-100，使用volatile修饰的变量控制用volatile修饰的变量来交替执行线程，需要while(true)死循环检测变量是否改变.当输出完结果后，线程不会正常结束，会被阻塞 12345678910111213141516171819202122232425262728293031public class OddExample2 &#123; public volatile boolean is_odd = true; private volatile int i = 0; public void odd() &#123; while (true) &#123; if (is_odd &amp;&amp; i &lt; 100) &#123; System.out.println(Thread.currentThread().getName() + ":偶数:" + i); i++; is_odd = false; &#125; &#125; &#125; public void ji() &#123; while (true) &#123; if (!is_odd &amp;&amp; i &lt; 100) &#123; System.out.println(Thread.currentThread().getName() + ":奇数:" + i); i++; is_odd = true; &#125; &#125; &#125; public static void main(String[] args) &#123; OddExample2 obj = new OddExample2(); new Thread(() -&gt; obj.odd()).start(); new Thread(() -&gt; obj.ji()).start(); &#125;&#125; 栗子3：两个线程交替打印1-100，使用synchronized123456789101112131415161718192021222324252627282930public class OddExample3 &#123; private static int i = 0; private static Object lock = new Object(); public static void main(String[] args) &#123; new Thread(() -&gt; &#123; while (i &lt; 100) &#123; // 代码块执行完释放锁后，可能又会进入该线程，两个线程会频繁竞争锁 synchronized (lock) &#123; if ((i &amp; 1) == 0) &#123; //位运算判断是否是偶数 System.out.println(Thread.currentThread().getName() + ":偶数:" + i); i++; &#125; &#125; &#125; &#125;).start(); new Thread(() -&gt; &#123; while (i &lt; 100) &#123; synchronized (lock) &#123; if ((i &amp; 1) == 1) &#123; //位运算判断是否是偶数 System.out.println(Thread.currentThread().getName() + ":奇数:" + i); i++; &#125; &#125; &#125; &#125;).start(); &#125;&#125; 面试题1：为什么wait方法需要在同步代码块内使用，而sleep方法不需要sleep方法主要是在线程内使用的，不涉及多个线程的通信。 wait方法放在同步代码块主要了为了防止死锁的发生。因为有了synchronized关键字，能保证在同一时刻，只会有一个线程执行代码快中的代码，避免了先notify，后wait这种情况。 面试题2：wait/notify方法为什么定义在Object类，而不是Thread类？wait/notify是需要在同步代码块内使用的，而同步代码快涉及到锁，锁是保存在对象的对象头的。任意对象都可以作为锁。另一方面，经常在同一个代码块中有多个锁配合使用，因此wait/notify定义在Object类是比较灵活的。 面试题3：调用Thread.wait()方法会发生什么情况？Thread也是一个对象，也可以调用wait方法。但是Thread类在线程结束后，会自动调用notifyAll方法。如果使用Thread对象作为锁，调用了Thread.wait方法，会对设计好的业务有影响。 面试题4：wait、sleep方法的相同点，不同点 相同点 阻塞 响应中断 不同点 所属类 释放锁：wait释放锁，sleep不释放锁 同步方法中：wait需要在同步方法中使用，sleep不需要 指定时间：sleep方法使用必须指定时间，而wait可以不指定时间]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal.md]]></title>
    <url>%2F2020%2F08%2F10%2F%E5%B9%B6%E5%8F%91%2F%E8%BF%9B%E9%98%B6%E7%AF%87%2FThreadLocal%2F</url>
    <content type="text"><![CDATA[1. 两大使用场景 每个线程需要一个自己独享的对象（通常是工具类，例如SimpleDateFormat和Random） 使用时重写ThreadLocal的initValue方法 需要保存到ThreadLocal里的对象的生成由我们控制 每个线程内需要保存全局变量（例如在拦截器中获取用户信息），可以让不同方法直接使用，避免参数传递的麻烦 使用时手动调用ThreadLocal的set方法 需要保存到ThreadLocal里的对象的生成时机不由我们随意控制 2.ThreadLocal的作用 让某个需要用到的对象在线程间隔离 在任何方法中都能获取到需要的对象 3.使用ThreadLocal的好处 达到线程安全 不需要加锁，提高执行效率 更高效地利用内存，节省开销 避免繁琐的传参 栗子1.每个线程都需要一个独享的ThreadLocal对象1234567891011121314151617181920212223242526/** * @Author Ming * @Date 2020/07/25 16:29 * @Description 每个线程都需要一个SimpleDateFormat对象，使用ThreadLocal来达到线程安全 */public class ThreadLocalNormalUseage01 &#123; private static ExecutorService executorService = Executors.newFixedThreadPool(10); private static ThreadLocal&lt;SimpleDateFormat&gt; threadLocal = ThreadLocal.withInitial(() -&gt; new SimpleDateFormat("yyyy-MM-dd hh:mm:ss")); public static void main(String[] args) &#123; for (int i = 0; i &lt; 1000; i++) &#123; int finalI = i; executorService.submit(() -&gt; &#123; String date = date(finalI); System.out.println(date); &#125;); &#125; executorService.shutdown(); &#125; public static String date(int seconds) &#123; Date date = new Date(1000 * seconds); return threadLocal.get().format(date); &#125;&#125; 4.ThreadLocal的原理 initialValue() 该方法会返回当前线程对应的“初始值”，这是一个延迟加载的方法，只有在调用get()方法的时候，才会触发 当线程第一个使用get方法访问变量时，将调用此方法，除非线程先前调用了set方法，在这种情况下，不会为线程调用本initialValue方法 每个线程最多调用一次initialValue方法，但如果已经调用了remove后，再调用get，则可以再次调用此方法 如果不重写本方法，这个方法会返回null 使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每 一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本 栗子11234567891011121314151617181920212223242526public class ThreadDemo21 &#123; public static void main(String[] args) throws InterruptedException &#123; ThreadLocal&lt;Integer&gt; th = new ThreadLocal&lt;Integer&gt;(); new Thread(() -&gt; &#123; try &#123; th.set(100); System.out.println("t1 set th=" + th.get()); // 100 Thread.sleep(2000); System.out.println("t1 get th=" + th.get()); // 100 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); Thread.sleep(1000); new Thread(() -&gt; &#123; Integer ele = th.get(); System.out.println("t2 get th=" + ele); // null th.set(200); System.out.println("t2 get th=" + th.get()); // 200 &#125;).start(); &#125;&#125; 执行结果： 线程t1先执行，设置th=100,sleep 2s，线程t2执行，先获取th的值=null，而不是线程t1设置的100。 线程t2设置th=200，线程t1sleep2s后获取th的值=100，而不是线程2设置的200。 每个线程的th变量是独立的。 1234t1 set th=100t2 get th=nullt2 get th=200t1 get th=100 ThreadLocal与InheritableThreadLocal Thread类中的threadLocals、inheritableThreadLocals成员变量为ThreadLocal.ThreadLocalMap对象 Map的key值是ThreadLocal对象本身，value是Object类型 ThreadLocal无法解决继承问题，而InheritableThreadLocal可以 InheritableThreadLocal继承自ThreadLocal InheritableThreadLocal可以帮助我们做链路追踪 栗子1：ThreadLocal只能获取当前线程设置的值12345678910111213141516171819public class ThreadLocalDemo0 &#123; public static ThreadLocal&lt;String&gt; tl = new ThreadLocal&lt;&gt;(); public static void main(String[] args) &#123; tl.set("Kevin是一个自由讲师"); Thread t0 = new Thread(() -&gt; &#123; // 子线程无法获取父线程ThreadLocal的值,因为他们是两个独立的用户线程，都使用各自的副本 System.out.println(Thread.currentThread().getName() + " get tl is : " + tl.get()); &#125;); t0.start(); // 主线程可以获取到 System.out.println(Thread.currentThread().getName() + " get tl is : " + tl.get()); &#125;&#125; 运行结果： 12main get tl is : Kevin是一个自由讲师Thread-0 get tl is : null 栗子2：InhertiableThreadLocal可以在父子线程中复制传递值1234567891011121314151617181920212223242526272829303132public class ThreadLocalDemo1 extends Thread &#123; // 多个线程之间读取副本, 父子线程之间复制传递 public static InheritableThreadLocal&lt;String&gt; tl = new InheritableThreadLocal&lt;&gt;(); public static void main(String[] args) throws InterruptedException &#123; tl.set("Kevin是一个自由讲师"); Thread t0 = new Thread(() -&gt; &#123; // t0线程先启动，可以获取main线程中设置的值，读取了main线程中的副本 System.out.println(Thread.currentThread().getName() + " get tl is : " + tl.get()); // t0线程修改值，并不影响其他线程 tl.set("After Set The Value Change to " + Thread.currentThread().getName()); System.out.println(Thread.currentThread().getName() + " get tl is : " + tl.get()); &#125;); Thread t1 = new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + " get tl is : " + tl.get()); tl.set("After Set The Value Change to " + Thread.currentThread().getName()); System.out.println(Thread.currentThread().getName() + " get tl is : " + tl.get()); &#125;); t0.start(); Thread.sleep(1000); t1.start(); System.out.println(Thread.currentThread().getName() + " get tl is : " + tl.get()); &#125;&#125; 执行结果： 12345Thread-0 get tl is : Kevin是一个自由讲师Thread-0 get tl is : After Set The Value Change to Thread-0main get tl is : Kevin是一个自由讲师Thread-1 get tl is : Kevin是一个自由讲师Thread-1 get tl is : After Set The Value Change to Thread-1 6.内存泄露内存泄露：某个对象不再有用，但是占用的内存不能被GC回收。 弱引用：如果这个对象只被弱引用关联（没有任何强引用关联），那么这个对象就可以被回收。ThredLocalMap的key就是一个弱引用 ThreadLocalMap的每个Entry都是一个对key的弱引用，同时，每个Entry都包含了一个对value的强引用 正常情况下，当线程终止，保存在ThreadLocal里的value会被垃圾回收，因为没有任何强引用了 但是，如果线程不终止（比如线程需要保持很久），那么key对应的value就不能被回收 因为value和Thread之间还存在这个强引用链路，所以导致value无法回收，就可能会出现OOM JDK在set，remove，rehash方法中会扫描key为null的Entry，并把对应的value设置为null，这样value对象就可以被回收 如何避免内存泄露：使用完ThreadLocal之后，应该调用remove方法，就会删除对应的Entry对象，可以避免内存泄露 7.空指针异常如果ThreadLocal没有设置初始值，就调用get方法，会返回null。这本身没有问题，但如果遇到拆箱的操作，就会引发NPE。原因在于拆箱调用的是对象的.valueOf方法。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unsafe.md]]></title>
    <url>%2F2020%2F08%2F10%2F%E5%B9%B6%E5%8F%91%2F%E8%BF%9B%E9%98%B6%E7%AF%87%2FunSafe%2F</url>
    <content type="text"><![CDATA[Unsafe类 AtomicXX类大量采用Unsafe类完成底层操作 位于JDK的rt.jar包中，由BootstrapClassLoader加载的核心类 Unsafe类中的方法几乎都为native方法 单例模式 栗子1：直接通过内存地址为对象的属性赋值12345678910111213141516171819202122232425public class UnsafeDemo0 &#123; private int age; public int getAge() &#123; return age; &#125; public static void main(String[] args) &#123; UnsafeDemo0 demo0 = new UnsafeDemo0(); // 获取Unsafe类实例,单例模式 Unsafe unsafe = Unsafe.getUnsafe(); try &#123; //获取age属性的内存偏移地址，需要通过反射 long ageOffset = unsafe.objectFieldOffset(UnsafeDemo0.class.getDeclaredField("age")); //设置age的值为11 unsafe.putInt(demo0, ageOffset, 11); //输出结果 System.out.println(demo0.getAge()); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行结果： 执行结果抛出异常，只有BootstrapClassLoader加载的类才能调用。 123Exception in thread "main" java.lang.SecurityException: Unsafe at sun.misc.Unsafe.getUnsafe(Unsafe.java:90) at thread06.UnsafeDemo0.main(UnsafeDemo0.java:20) 栗子2： 通过反射模式可以突破Unsafe类的安全限制]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存模型.md]]></title>
    <url>%2F2020%2F08%2F10%2F%E5%B9%B6%E5%8F%91%2F%E8%BF%9B%E9%98%B6%E7%AF%87%2FJMM%2F</url>
    <content type="text"><![CDATA[三兄弟：JVM内存结构 VS Java内存模型 VS Java对象模型JVM内存结构 共享区域 堆区（所有线程共享） 存储的全部是对象实例（通过new等指令创建的，并会被垃圾回收；数组也是保存在堆上面的，即使是基本类型的数据，也是保存在堆中的。因为在Java中，数组是对象），是内存中最大的一块。 堆的优势是可以在运行时动态地分配内存空间，不必事先告诉编译器。 方法区（所有线程共享） 它用于存储虚拟机已经加载的static静态变量、类信息、常量。 还存放永久引用，比如static People p = new People();的p引用。 运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。存放final修饰的。 线程独有 栈区（每个线程私有） 每个线程包含一个栈区，栈中保存基础数据类型（byte，short，int，long，float，double，boolean，char）的对象、自定义对象的引用(不是对象本身)和returnAddress（指向了一条字节码指令的地址）。 每个方法从被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。每个栈中的数据(基本类型的局部变量、参数、对象引用)都是私有的，其他栈不能访问。 在编译期间就确定了大小，运行期间不会改变大小。 本地方法栈（每个线程私有） 与虚拟机栈基本类似，区别在于虚拟机栈为虚拟机执行的java方法服务，而本地方法栈则是为Native方法服务。 程序计数器（每个线程私有） 是最小的一块内存区域，它的作用是当前线程所执行的字节码的行号指示器，在虚拟机的模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。 Java对象模型 Java对象自身的存储模型。 每个对象的实例保存在堆中，对象的引用保存在栈中。 每个对象包括对象头和实例数据 JMM是什么 为什么需要JMM? ​ JVM实现会带来不同的“翻译”，不同的CPU平台的机器指令又千差万别，无法保证并发安全的效果一致 是一组规范，需要各个JVM的实现来遵守JMM规范，以便于开发者可以利用这些规范，更方便地开发多线程程序。 如果没有这样的一个JMM内存模型来规范，那么很可能经过了不同JVM的不同规则的重排序之后，导致不同的虚拟机上运行的结果不一样，那是很大的问题。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>JMM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原子性.md]]></title>
    <url>%2F2020%2F08%2F10%2F%E5%B9%B6%E5%8F%91%2F%E8%BF%9B%E9%98%B6%E7%AF%87%2F%E5%8E%9F%E5%AD%90%E6%80%A7%2F</url>
    <content type="text"><![CDATA[Java中的原子性操作有哪些 除了long和double之外的基本类型的赋值操作 所有引用类型的赋值操作，不管是32位机器还是64位机器 Atomic包中所有类的原子操作]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volatile.md]]></title>
    <url>%2F2020%2F08%2F10%2F%E5%B9%B6%E5%8F%91%2F%E8%BF%9B%E9%98%B6%E7%AF%87%2Fvolatile%2F</url>
    <content type="text"><![CDATA[volatile保证可见性，不保证原子性 volatile强制线程到共享内存中读取数据，而不从线程工作内存中读取，从而使变量在多个线程中可见 volatile无法保证原子性，volatile属于轻量级的同步，性能比synchronized强很多(不加锁)，但是只 保证线程见的可见性，并不能替代synchronized的同步功能，netty框架中大量使用了volatile 栗子1：volatile不能保证原子性sum属性加了volatile关键字 12345678910111213141516171819202122232425262728293031323334353637public class ThreadDemo14 implements Runnable &#123; public volatile static Integer sum = 0; public static void add() &#123; System.out.println(Thread.currentThread().getName() + "初始sum=" + sum); for (int i = 0; i &lt; 10000; i++) &#123; sum++; &#125; System.out.println(Thread.currentThread().getName() + "计算后sum=" + sum); &#125; @Override public void run() &#123; add(); &#125; public static void main(String[] args) &#123; //如果volatile具有原子性,那么10个线程并发调用，最终结果应该为100000 ExecutorService es = Executors.newFixedThreadPool(10); for (int i = 0; i &lt; 10; i++) &#123; es.submit(new ThreadDemo14()); &#125; es.shutdown(); while (true) &#123; if (es.isTerminated()) &#123; System.out.println("sum最终=" + sum); if (sum == 100000) &#123; System.out.println(sum + "=ok"); &#125; else &#123; System.out.println(sum + "=no"); &#125; break; &#125; &#125; &#125;&#125; 运行结果: 多次运行可能结果都不一样。因为volatile不能保证原子性，可能线程A把sum改变了，还没来得及设置回主内存，又被其他线程给读取了。 12345678910111213141516171819202122pool-1-thread-1初始sum=0pool-1-thread-3初始sum=0pool-1-thread-2初始sum=0pool-1-thread-5初始sum=0pool-1-thread-3计算后sum=4486pool-1-thread-1计算后sum=6411pool-1-thread-4初始sum=7627pool-1-thread-2计算后sum=9046pool-1-thread-6初始sum=14162pool-1-thread-7初始sum=17079pool-1-thread-4计算后sum=19511pool-1-thread-8初始sum=21795pool-1-thread-5计算后sum=24844pool-1-thread-6计算后sum=26518pool-1-thread-9初始sum=28104pool-1-thread-10初始sum=29595pool-1-thread-8计算后sum=33121pool-1-thread-7计算后sum=33111pool-1-thread-9计算后sum=41465pool-1-thread-10计算后sum=42512sum最终=4251242512=no volatile与static区别 static保证唯一性，不保证一致性，多个实例共享一个静态变量 volatile保证一致性，不保证唯一性，多个实例有多个volatile变量 Atomic类的原子性==Actomic类采用了CAS这种非锁机制== 栗子1：使用AtomicInteger等原子类可以保证共享变量的原子性12345678910111213141516171819202122232425262728293031323334353637public class ThreadDemo14 implements Runnable &#123; public static AtomicInteger sum = new AtomicInteger(0); public static void add() &#123; System.out.println(Thread.currentThread().getName() + "初始sum=" + sum); for (int i = 0; i &lt; 10000; i++) &#123; sum.addAndGet(1); &#125; System.out.println(Thread.currentThread().getName() + "计算后sum=" + sum); &#125; @Override public void run() &#123; add(); &#125; public static void main(String[] args) &#123; //如果volatile具有原子性,那么10个线程并发调用，最终结果应该为100000 ExecutorService es = Executors.newFixedThreadPool(10); for (int i = 0; i &lt; 10; i++) &#123; es.submit(new ThreadDemo14()); &#125; es.shutdown(); while (true) &#123; if (es.isTerminated()) &#123; System.out.println("sum最终=" + sum); if (sum.get() == 100000) &#123; System.out.println(sum + "=ok"); &#125; else &#123; System.out.println(sum + "=no"); &#125; break; &#125; &#125; &#125;&#125; 执行结果： 不管运行多少次，结果都是正确的 12345678910111213141516171819202122pool-1-thread-1初始sum=0pool-1-thread-3初始sum=0pool-1-thread-2初始sum=0pool-1-thread-5初始sum=14727pool-1-thread-10初始sum=19921pool-1-thread-3计算后sum=26493pool-1-thread-6初始sum=32980pool-1-thread-1计算后sum=35974pool-1-thread-2计算后sum=41300pool-1-thread-4初始sum=54770pool-1-thread-10计算后sum=56532pool-1-thread-6计算后sum=59183pool-1-thread-7初始sum=60117pool-1-thread-8初始sum=61625pool-1-thread-5计算后sum=68908pool-1-thread-9初始sum=79628pool-1-thread-4计算后sum=82182pool-1-thread-7计算后sum=92269pool-1-thread-8计算后sum=95401pool-1-thread-9计算后sum=100000sum最终=100000100000=ok 栗子2： Atomic类不能保证成员方法的原子性1234567891011121314151617181920212223242526272829303132public class ThreadDemo15 implements Runnable &#123; //原子类 private static AtomicInteger sum = new AtomicInteger(0); // 如果add方法是原子性的,那么每次的结果都是10的整数倍 // synchronized加锁可以保证原子性 public static void add() &#123; sum.addAndGet(1); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; sum.addAndGet(9); System.out.println(sum); &#125; @Override public void run() &#123; add(); &#125; public static void main(String[] args) &#123; //10个线程调用，每个线程得到10的倍数， 最终结果应该为100，才是正确的 ExecutorService es = Executors.newFixedThreadPool(10); for (int i = 0; i &lt; 10; i++) &#123; es.submit(new ThreadDemo15()); &#125; es.shutdown(); &#125;&#125; 执行结果： 12345678910281009182377364554628 使用synchronized可以保证方法的原子性。 12345678910public synchronized static void add() &#123; sum.addAndGet(1); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; sum.addAndGet(9); System.out.println(sum);&#125; 执行结果： 12345678910102030405060708090100 CAS（Compare and swap） JDK提供的非阻塞原子操作，通过硬件保证了比较、更新操作的原子性 JDK的Unsafe类提供了一系列的compareAndSwap*方法来支持CAS操作 解决ABA问题： 给变量分配时间戳、版本来解决ABA问题 JDK中使用java.util.concurrent.atomic.AtomicStampedReference类给每个变量的状态都分配一个时间 戳，避免ABA问题产生。 栗子1：ABA问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class CasDemo0 &#123; private static AtomicStampedReference&lt;Integer&gt; atomic = new AtomicStampedReference&lt;&gt;(100, 0); public static void main(String[] args) throws InterruptedException &#123; Thread t0 = new Thread(() -&gt; &#123; try &#123; TimeUnit.SECONDS.sleep(1); boolean sucess = atomic.compareAndSet(100, 101, atomic.getStamp(), atomic.getStamp() + 1); System.out.println(Thread.currentThread().getName() + " set 100&gt;101 : " + sucess); sucess = atomic.compareAndSet(101, 100, atomic.getStamp(), atomic.getStamp() + 1); System.out.println(Thread.currentThread().getName() + " set 101&gt;100 : " + sucess); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); t0.start(); Thread t1 = new Thread(() -&gt; &#123; try &#123; int stamp = atomic.getStamp(); System.out.println(Thread.currentThread().getName() + " 修改之前 : " + stamp); TimeUnit.SECONDS.sleep(2); int stamp1 = atomic.getStamp(); System.out.println(Thread.currentThread().getName() + " 等待两秒之后,版本被t0线程修改为 : " + stamp1); // 以下两次修改都不会成功,因为版本不符,虽然期待值是相同的,因此解决了ABA问题 boolean success = atomic.compareAndSet(100, 101, stamp, stamp + 1); System.out.println(Thread.currentThread().getName() + " set 100&gt;101 使用错误的时间戳: " + success); success = atomic.compareAndSet(101, 100, stamp, stamp + 1); System.out.println(Thread.currentThread().getName() + " set 101&gt;100 使用错误的时间戳: " + success); // 以下修改是成功的,因为使用了正确的版本号,正确的期待值 success = atomic.compareAndSet(100, 101, stamp1, stamp1 + 1); System.out.println(Thread.currentThread().getName() + " set 100&gt;101 使用正确的时间戳: " + success); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); t1.start(); t0.join(); t1.join(); System.out.println("main is over"); &#125;&#125; 执行结果： 12345678Thread-1 修改之前 : 0Thread-0 set 100&gt;101 : trueThread-0 set 101&gt;100 : trueThread-1 等待两秒之后,版本被t0线程修改为 : 2Thread-1 set 100&gt;101 使用错误的时间戳: falseThread-1 set 101&gt;100 使用错误的时间戳: falseThread-1 set 100&gt;101 使用正确的时间戳: truemain is over]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式.md]]></title>
    <url>%2F2020%2F08%2F10%2F%E5%B9%B6%E5%8F%91%2F%E8%BF%9B%E9%98%B6%E7%AF%87%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1.饿汉式-&gt;静态常量[可用]12345678910public class Singleton1 &#123; // 在类加载的时候初始化 private final static Singleton1 instance = new Singleton1(); private Singleton1()&#123;&#125; public static Singleton1 getInstance()&#123; return instance; &#125;&#125; 2.饿汉式-&gt;静态代码块[可用]12345678910111213141516public class Singleton2 &#123; private final static Singleton2 instance; // 在静态代码块中初始化 static &#123; instance = new Singleton2(); &#125; private Singleton2() &#123; &#125; public static Singleton2 getInstance() &#123; return instance; &#125;&#125; 3.懒汉式-&gt;线程不安全123456789101112131415161718public class Singleton3 &#123; private static Singleton3 instance; private Singleton3() &#123; &#125; // 懒汉式,在实例不为空时,直接返回实例对象,为空时,创建一个实例返回 // 如果多个线程同时进入if语句，会导致线程不安全 public static Singleton3 getInstance() &#123; if(instance == null)&#123; instance = new Singleton3(); &#125; return instance; &#125;&#125; 4.懒汉式-&gt;线程安全12345678910111213141516public class Singleton4 &#123; private static Singleton4 instance; private Singleton4() &#123; &#125; // 加锁保证线程安全，效率低下 public static synchronized Singleton4 getInstance() &#123; if (instance == null) &#123; instance = new Singleton4(); &#125; return instance; &#125;&#125; 5.懒汉式-&gt;线程不安全12345678910111213141516171819public class Singleton5 &#123; private static Singleton5 instance; private Singleton5() &#123; &#125; // 目的是为了降低锁的粒度，提高性能，但没达到线程安全 // 如果第一个线程创建了对象，释放锁，第二个线程进来，又创建了一个新的对象 public static Singleton5 getInstance() &#123; if (instance == null) &#123; synchronized (Singleton5.class)&#123; instance = new Singleton5(); &#125; &#125; return instance; &#125;&#125; 6.双重检查[推荐使用]优点：线程安全，效率较高 1234567891011121314151617181920public class Singleton6 &#123; // volatile保证可见性和禁止重排序，对象的创建过程不是原子性的，会有重排序的可能 private volatile static Singleton6 instance; private Singleton6() &#123; &#125; // 双重检查 public static Singleton6 getInstance() &#123; if (instance == null) &#123; synchronized (Singleton6.class) &#123; if (instance == null) &#123; instance = new Singleton6(); &#125; &#125; &#125; return instance; &#125;&#125; 7.静态内部类[推荐用]1234567891011121314public class Singleton7 &#123; private Singleton7() &#123; &#125; static class Singleton7Inner &#123; private static final Singleton7 instance = new Singleton7(); &#125; // 返回静态内部类创建的实例，由JVM保证线程安全 public static Singleton7 getInstance() &#123; return Singleton7Inner.instance; &#125;&#125; 8.枚举12345678public enum Singleton8 &#123; INSTANCE; // 只是为了示范调用INSTANCE的方法，实际上一行代码就完成了INSTANCE的单例模式 public void whatever() &#123; &#125;&#125; 各种写法的适用场合 最好的方法是利用枚举，因为还可以防止反序列化重新创建新的对象 非线程安全的方法不能使用 如果程序一开始要加载的资源太多，那么就应该使用懒加载 饿汉式如果是对象的创建需要配置文件就不适用 懒加载虽然好，但是静态内部类这种方式会增加编程的复杂性]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可见性.md]]></title>
    <url>%2F2020%2F08%2F10%2F%E5%B9%B6%E5%8F%91%2F%E8%BF%9B%E9%98%B6%E7%AF%87%2F%E5%8F%AF%E8%A7%81%E6%80%A7%2F</url>
    <content type="text"><![CDATA[为什么会有可见性问题 高速缓存的容量比主内存小，但是速度仅次于寄存器，所以在CPU和主内存之间就多了Cache层 线程间的对于共享变量的可见性问题不是直接由多核引起的，而是由多缓存引起的。如果所有个核心都只用一个缓存，那么也就不存在内存可见性问题了。 每个核心都会将自己需要的数据读到独占缓存中，数据修改后也是写入到缓存中，然后等待刷入到主存中。所以会导致有些核心读取的值是一个过期的值。 什么是主内存和本地内存Java 作为高级语言，屏蔽了CPU cache等底层细节，用 JMM 定义了一套读写内存数据的规范，虽然我们不再需要关心一级缓存和二级缓存的问题，但是，JMM 抽象了主内存和本地内存的概念。 主内存和本地内存的关系 所有的变量都存储在主内存中，同时每个线程也有自己独立的工作内存，工作内存中的变量内容是主内存中的拷贝 线程不能直接读写主内存中的变量,而是只能操作自己工作内存中的变量，然后再同步到主内存中 主内存是多个线程共享的，但线程间不共享工作内存,如果线程间需要通信，必须借助主内存中转来完成 所有的共享变量存在于主内存中，每个线程有自己的本地内存，而且线程读写共享数据也是通过本地内存交换的，所以才导致了可见性问题。 什么是happen-before原则 解决可见性问题的：在时间上，动作A发生在动作B之前，B保证能看见A，这就是happens-before。 如果两个操作不具备happens-before，那么JVM是可以根据需要自由排序的，但是如果具备happens-before（比如新建线程时，run方法里面的语句一定发生在thread.start()之前），那么JVM也不能改变它们之间的顺序。 Happens-Before规则有哪些？ volatile是什么 volatile是一种同步机制，比synchronized或者lock相关类更轻量，因为使用volatile并不会发生上下文切换等开销很大的行为 如果一个变量被修饰成volatile，那么JVM就知道了这个变量可能会被并发修改 开销小，相应的能力也小，虽然是volatile是用来同步的保证线程安全的，但是volatile做不到synchronized那样的原子保护，volatile仅在很有限的场景下才能发挥作用 volatile的适用场合 boolean flag，如果一个共享变量自始至终只被各个线程赋值（不依赖于之前的状态），而没有其他的操作，那么就可以用volatile来代替synchronized或者代替其他原子变量，因为赋值自身是有原子性的，而volatile又保证了可见性，所以就足以保证线程安全 作为刷新之前变量的触发器 volatile的两点作用 可见性：读一个volatile变量之前，需要先使相应的本地缓存失效，这样就必须到主内存读取最新值，写一个volatile属性会立即刷入到主内存 禁止指令重排序优化：解决单例双重锁乱序问题 volatile总结 适用场景：某个属性被多个线程共享，其中有一个线程修改了此属性，其他线程可以立即得到修改后的值，比如boolean flag。或者作为触发器，实现轻量级同步。 volatile属性的读写操作都是无锁的，它不能替代synchronized，因为它没有提供原子性和互坼性。因为无锁，不需要花费时间在获取锁和释放锁上，所以说它是低成本的。 volatile只能作用于属性，我们用volatile修饰属性，这样编译器就不会对这个属性做指令重排序。 volatile可以使得long和double的赋值是原子的 synchronized保证可见性 synchronized既保证了原子性，又保证了可见性 synchronized不仅让被保护的代码安全，还近朱者赤]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发队列.md]]></title>
    <url>%2F2020%2F08%2F10%2F%E5%B9%B6%E5%8F%91%2F%E8%BF%9B%E9%98%B6%E7%AF%87%2F%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[并发-无阻塞队列ConcurrentLinkedQueue并发无阻塞队列，BlockingQueue并发阻塞队列。 ConcurrentLinkedQueue实现Queue接口，BlockingQueue本身是一个接口，继承Queue接口。 ConcurrentLinkedQueue 无阻赛、无锁、高性能、无界队列(直至内存耗尽)、线程安全，性能优于BlockingQueue、不允许null值 使用CAS算法进行入队和出队操作 栗子1：ConcurrentLinkedQueue基本操作12345678910111213141516171819202122232425262728293031public class DemoThread29 &#123; public static void main(String[] args) &#123; ConcurrentLinkedQueue&lt;Integer&gt; queue = new ConcurrentLinkedQueue&lt;&gt;(); queue.add(1); // add方法实际调用了offer方法 queue.add(2); // offer方法与add没有区别 queue.offer(3); queue.offer(4); //不允许添加null元素// queue.add(null); System.out.println(queue); System.out.println("[1]peek=" + queue.peek()); //读取头元素,但是不移除 System.out.println("[2]size=" + queue.size()); //peek方法不会导致size改变 System.out.println("[3]poll=" + queue.poll()); //读取头元素，并且移除 System.out.println("[4]size=" + queue.size()); //poll方法导致size改变 System.out.println("[5]poll=" + queue.poll()); System.out.println("[6]poll=" + queue.poll()); System.out.println("[7]poll=" + queue.poll()); System.out.println("[8]size=" + queue.size()); System.out.println("peek=" + queue.peek()); //队列为空, 读取头元素，返回null System.out.println("pool=" + queue.poll()); //队列为空, 读取头元素并移除, 返回null &#125;&#125; 执行结果： 1234567891011[1, 2, 3, 4][1]peek=1[2]size=4[3]poll=1[4]size=3[5]poll=2[6]poll=3[7]poll=4[8]size=0peek=nullpool=null ArrayBlockingQueue 不允许添加null元素，三种添加方法都不允许添加null元素 添加方法 add：如果队列满了，抛出异常 1java.lang.IllegalStateException: Queue full offer：如果队列满了，不阻塞，不抛出异常。可以设置最大阻塞时间。 12// 可设置最大阻塞时间,5秒,如果队列还是满的,则不阻塞，不抛出异常queue.offer(6, 5, TimeUnit.SECONDS); put：如果队列满了，永远阻塞，不抛出异常 获取方法 peek：读取头元素不移除。如果队列为空,返回null,不阻塞, 不抛异常 poll：读取头元素，并移除。如果队列为空,返回null,不阻塞, 不抛异常。可以设置最大最大阻塞时间 12// 可指定阻塞时间,2秒,如果队列依然为空,则返回null,不抛异常queue.poll(2, TimeUnit.SECONDS) take：读取头元素，并移除。如果队列为空,则永远阻塞,不抛出异常 转换方法 drainTo：取出queue中指定个数的元素放入集合中,并移除。如果队列为空时，不阻塞，不抛出异常 1queue.drainTo(list, 2); 栗子1：drainTo转换为List1234567891011public static void testTake2() &#123; ArrayBlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;Integer&gt;(3); queue.add(1); queue.add(2); queue.add(3); ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); queue.drainTo(list, 2); // 取出queue中指定个数的元素放入list中,并移除 System.out.println("list&gt;&gt;" + list); System.out.println("queue&gt;&gt;" + queue); &#125; 执行结果： 12list&gt;&gt;[1, 2]queue&gt;&gt;[3] 栗子2：空队列drainTo转换12345678910111213141516public static void testTake3() &#123; ArrayBlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;Integer&gt;(3); queue.add(1); queue.add(2); queue.add(3); ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); queue.drainTo(list); // 取出queue中的全部元素放入list中,并移除 System.out.println("1&gt;&gt;" + list); System.out.println("2&gt;&gt;" + queue); ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); queue.drainTo(list1); // 当队列为空时不抛出异常 System.out.println("3&gt;&gt;" + list1); System.out.println("4&gt;&gt;" + queue);&#125; 执行结果： 12341&gt;&gt;[1, 2, 3]2&gt;&gt;[]3&gt;&gt;[]4&gt;&gt;[]]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[锁的分类.md]]></title>
    <url>%2F2020%2F08%2F10%2F%E5%B9%B6%E5%8F%91%2F%E8%BF%9B%E9%98%B6%E7%AF%87%2F%E9%94%81%2F</url>
    <content type="text"><![CDATA[1.锁的分类 2.悲观锁和乐观锁 悲观锁（互斥同步锁） 典型例子：Synchronized、lock 乐观锁（非互斥同步锁） 典型例子：原子类、并发容器 使用CAS算法实现 3.悲观锁和乐观锁的开销对比 悲观锁的原始开销要高于乐观锁，但是特点是一劳永逸，临界区持锁时间就算越来越长，也不会对互斥锁的开销造成影响 乐观锁一开始的开销比悲观锁小，但是如果自旋时间很长或者不停重试，那么消耗的资源也会越来越多 4.使用场景 悲观锁：适合并发写入多的情况，适用于临界区持锁时间比较长的情况，悲观锁可以避免大量的无用自旋等消耗 临界区有IO操作 临界区代码复杂或者循环量大 临界区竞争非常激烈 乐观锁：适合并发写入少，大部分是读取的场景，不加锁的能让读取性能大幅提升 5.可重入锁 典型例子：Synchronized、ReentranceLock getHoldCount() 获取可重入的次数 6.读锁插队策略和升降级 公平锁 不允许插队 非公平锁 写锁可以随时插队 读锁仅在等待队列头节点不是想获取写锁线程的时候可以插队，否则可能会造成饥饿现象 升降级策略：只能降级，不能升级 栗子1：读锁插队1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * @Author Ming * @Date 2020/07/26 19:12 * @Description 演示当队列中第一个不是写锁的时候，读锁是可以插队的 */public class ReentranceReadWriteLockTest &#123; // 非公平锁才能有插队 private final ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock(false); private final ReentrantReadWriteLock.ReadLock readLock = reentrantReadWriteLock.readLock(); private final ReentrantReadWriteLock.WriteLock writeLock = reentrantReadWriteLock.writeLock(); public void read() &#123; System.out.println(Thread.currentThread().getName() + "尝试获取读锁"); readLock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + "获取到了读锁"); Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(Thread.currentThread().getName() + "释放读锁"); readLock.unlock(); &#125; &#125; public void write() &#123; System.out.println(Thread.currentThread().getName() + "尝试获取写锁"); writeLock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + "获取到了写锁"); Thread.sleep(40); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(Thread.currentThread().getName() + "释放写锁"); writeLock.unlock(); &#125; &#125; public static void main(String[] args) &#123; ReentranceReadWriteLockTest reentranceReadWriteLockTest = new ReentranceReadWriteLockTest(); new Thread(() -&gt; reentranceReadWriteLockTest.write(), "thread-1").start(); new Thread(() -&gt; reentranceReadWriteLockTest.read(), "thread-2").start(); new Thread(() -&gt; reentranceReadWriteLockTest.read(), "thread-3").start(); new Thread(() -&gt; reentranceReadWriteLockTest.write(), "thread-4").start(); new Thread(() -&gt; &#123; Thread[] threads = new Thread[1000]; for (int i = 0; i &lt; 1000; i++) &#123; threads[i] = new Thread(() -&gt; reentranceReadWriteLockTest.read(), "子线程创建的Thread" + i); &#125; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i].start(); &#125; &#125;).start(); &#125;&#125; 7.读写锁的适用场景ReentranceReadWriteLock适用于读多写少的情况，合理使用可以进一步提高并发效率。 8.自旋锁 阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间 如果同步代码快中的内容过于简单，状态转换消耗的时间很可能比用户代码执行的时间还要长 在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失 如果锁被占用的时间很长，那么自旋的线程只会白浪费处理资源 atomic包下的类基本都是自旋锁的实现 自旋锁实现原理是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作 9.自旋锁的适用场景 自旋锁一般用于多核的服务器，在并发度不是特别高的情况下，比阻塞锁的效率高 适用于临界区比较短小的情况，否则如果临界区很大（线程一旦拿到锁，很久以后才会释放），那也是不适合的 10.锁优化 缩小同步代码块 尽量不要锁住方法 减少请求锁的次数 锁中尽量不要再包含锁 选择合适的锁类型或合适的工具类]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程池.md]]></title>
    <url>%2F2020%2F08%2F10%2F%E5%B9%B6%E5%8F%91%2F%E8%BF%9B%E9%98%B6%E7%AF%87%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[1.为什么要使用线程池 反复创建线程开销大 过多的线程会占用太多内存 2.线程池的好处 加快响应速度 合理利用CPU和内存 统一管理 3.线程池适用场景 服务器接收到大量的请求时，使用线程池技术是非常合适的，它可以大大减少线程的创建和销毁次数，提高服务器的工作效率 在开发中，如果需要创建5个以上的线程，就可以使用线程池来处理 4.线程池的参数 corePoolSize 核心线程数，线程池在完成初始化后，默认情况下，线程池中并没有任何线程，线程池会等待有任务到来时再创建新线程去执行任务 maxPoolSize 最大线程数，线程池有可能会在核心线程数的基础上，额外增加一些线程，但是这些新增加的线程数有一个上限 keepAliveTime 如果线程池当前的线程数多于corePoolSize,那么如果多余的线程空闲时间超过keepAliveTime,它们就会被终止 ThreadFactory 新的线程是由ThreadFactory创建的，默认使用Executors.defaultThreadFactory()，创建处理的线程都在同一个线程组，拥有统一的NORM_PRIORITY优先级并且都不是守护线程。如果自己指定ThreadFactory，那么就可以改变线程名、线程组、优先级、是否是守护线程等 通常我们用默认的ThreadFactory就可以了 workQueue 直接交换：SynchronousQueue 无界队列：LinkedBlockingQueue 有界队列：ArrayBlockingQueue 5.添加线程规则 如果线程数小于corePoolSize,即使其他工作线程处于空闲状态，也会创建一个新线程来运行新任务 如果线程数等于（或大于）corePoolSize但少于maxPoolSize,则将任务放入队列 如果队列已满，并且线程数小于maxPoolSize,则创建一个新线程来运行任务 如果队列已满，并且线程数大于maxPoolSize,则拒绝该线程 6.增减线程的特点 如果设置corePoolSize和maxPoolSize相同，就可以创建固定大小的线程数 线程池希望保持较少的线程数，并且只有在负载变得很大时才增加它 通过设置maxPoolSize为很高的值，可以允许线程池容纳任意数量的并发任务 如果使用的是无界队列（例如LinkedBolckingQueue），那么线程数就不会超过corePoolSize 7. 自带线程池介绍 newFixedThreadPool 由于传进去的LinkedBlockingQueue是没有容量上限的，所以当请求数越来越多，并且无法及时处理完毕的时候，会容易造成占用大量的内存，可能会导致OOM newSingleThreadPool 和FixedThreadPool的原理基本一样，只不过把线程数直接设置成了1，所以这也会导致同样的问题，可能会占用大量的内存 newCacheThreadPool 无界队列，可以自动回收多余的线程 maxPoolSize被设置为Integer.MAX_VALUE，这可能会创建数量非常多的线程，甚至导致OOM newScheduledThreadPool 支持定时以及周期性任务执行 newFixedThreadPool newSingleThreadPool newCacheThreadPool newScheduledThreadPool corePoolSize 构造函数传参 1 0 构造方法传参 maxPoolSize 构造函数传参 1 Integer.MAX_VALUE Integer.MAX_VALUE keepAliveTime 0 0 60 0 workQueue LinkedBlockingQueue LinkedBlockingQueue SynchrousQueue DelayedWorkQueue 8.线程池里的线程数量设定为多少比较合适 CPU密集型（加密，计算hash等）：最佳线程数为CPU核心数1-2倍左右 耗时IO型（读写数据库、文件、网络独写等）：最佳线程数一般会大于cpu核心数很多倍 线程数=CPU核心数*（1 + 平均等待时间/平均工作时间） 9.停止线程池的方法 shutdown：等待线程执行完毕后才终止 isShutdown：判断是否执行了shutDown方法 isTerminated：判断线程是否终止 awaitTermination：判断在指定时间内线程是否终止 shutDownNoe：立即终止线程，执行中的线程会被中断，队列中的线程会以List返回 10.线程池状态 RUNNING:接受新任务并处理排队任务 SHUTDOWN:不接受新任务，但处理排队任务 STOP:不接受新任务，也不处理排队任务，并中断正在进行的任务 TIDYING:所有任务都已终止，worderCount为零时，线程会转换到TIDYING状态，并将运行terminate()钩子方法 TERMINATED:terminate()运行完成 11.使用线程池需要注意的地方 避免任务堆积 避免线程数过度增加 排查线程泄露（线程数量是否超出预期）]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
</search>
